// Generated by CoffeeScript 1.7.1
(function() {
  var Portal, counter, idGenerator, inventory_key_list, x,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  counter = Math.floor(ROT.RNG.getUniform() * 1000000);

  idGenerator = function() {
    counter += 1;
    return counter;
  };

  window.Brew.Thing = (function() {
    function Thing(objtype) {
      this.objtype = objtype;
      this.id = idGenerator();
      this.code = null;
      this.color = null;
      this.bgcolor = null;
      this.coordinates = {
        x: null,
        y: null
      };
      this.flags = [];
      this.flagcounters = {};
      this.stats = {};
    }

    Thing.prototype.compare = function(other_thing) {
      return id === other_thing.id;
    };

    Thing.prototype.getSpeed = function() {
      return 100;
    };

    Thing.prototype.getLocation = function() {
      return coordinates;
    };

    Thing.prototype.setLocation = function(xy) {
      this.coordinates = xy;
      return true;
    };

    Thing.prototype.getFlags = function() {
      return this.flags;
    };

    Thing.prototype.hasFlag = function(flag) {
      return __indexOf.call(this.flags, flag) >= 0;
    };

    Thing.prototype.setFlag = function(flag) {
      if (!this.hasFlag(flag)) {
        this.flags.push(flag);
      }
      return true;
    };

    Thing.prototype.removeFlag = function(flag) {
      if (this.hasFlag(flag)) {
        this.flags.remove(flag);
        return true;
      } else {
        return false;
      }
    };

    Thing.prototype.toggleFlag = function(flag) {
      if (this.hasFlag(flag)) {
        return this.removeFlag(flag);
      } else {
        return this.setFlag(flag);
      }
    };

    Thing.prototype.getFlagCounters = function() {
      var f, v;
      return (function() {
        var _ref, _results;
        _ref = this.flagcounters;
        _results = [];
        for (f in _ref) {
          if (!__hasProp.call(_ref, f)) continue;
          v = _ref[f];
          _results.push(f);
        }
        return _results;
      }).call(this);
    };

    Thing.prototype.setFlagCounter = function(flag, stop_turn) {
      this.setFlag(flag);
      this.flagcounters[flag] = stop_turn;
      return true;
    };

    Thing.prototype.removeFlagCounter = function(flag) {
      this.removeFlag(flag);
      delete this.flagcounters[flag];
      return true;
    };

    Thing.prototype.getFlagCount = function(flag) {
      return this.flagcounters[flag];
    };

    Thing.prototype.createStat = function(stat_name, init_value) {
      this.stats[stat_name] = new Brew.Stat(stat_name, init_value);
      return true;
    };

    Thing.prototype.getStat = function(stat_name) {
      return this.stats[stat_name];
    };

    Thing.prototype.toObject = function() {
      return {
        "objtype": this.objtype,
        "def_id": this.def_id,
        "id": this.id,
        "code": this.code,
        "color": this.color,
        "bgcolor": this.bgcolor,
        "name": this.name,
        "group": this.group,
        "coordinates": this.coordinates.toObject(),
        "stats": this.stats
      };
    };

    return Thing;

  })();

  window.Brew.Terrain = (function(_super) {
    __extends(Terrain, _super);

    function Terrain(terrain_info) {
      var param, value, _ref, _ref1, _ref2, _ref3, _ref4;
      Terrain.__super__.constructor.call(this, "terrain");
      this.group = (_ref = terrain_info.group) != null ? _ref : terrain_info.name;
      this.bgcolor = (_ref1 = terrain_info.bgcolor) != null ? _ref1 : Brew.colors.black;
      this.blocks_vision = (_ref2 = terrain_info.blocks_vision) != null ? _ref2 : false;
      this.blocks_walking = (_ref3 = terrain_info.blocks_walking) != null ? _ref3 : false;
      this.blocks_flying = (_ref4 = terrain_info.blocks_flying) != null ? _ref4 : false;
      this.code = typeIsArray(terrain_info.code) ? terrain_info.code[Math.floor(ROT.RNG.getUniform() * terrain_info.code.length)] : terrain_info.code;
      for (param in terrain_info) {
        if (!__hasProp.call(terrain_info, param)) continue;
        value = terrain_info[param];
        if (this[param] != null) {
          continue;
        }
        this[param] = value;
      }
    }

    return Terrain;

  })(Brew.Thing);

  window.Brew.Feature = (function(_super) {
    __extends(Feature, _super);

    function Feature(feature_info) {
      var param, value, _ref, _ref1, _ref2, _ref3;
      Feature.__super__.constructor.call(this, "feature");
      this.group = (_ref = feature_info.group) != null ? _ref : feature_info.name;
      this.code = this.generateCode(feature_info);
      this.color = (_ref1 = feature_info.color) != null ? _ref1 : null;
      this.bgcolor = (_ref2 = feature_info.bgcolor) != null ? _ref2 : [0, 0, 0];
      this.intensity = (_ref3 = feature_info.intensity) != null ? _ref3 : 0;
      for (param in feature_info) {
        if (!__hasProp.call(feature_info, param)) continue;
        value = feature_info[param];
        if (this[param] != null) {
          continue;
        }
        this[param] = value;
      }
    }

    Feature.prototype.generateCode = function(feature_info) {
      if (feature_info.code == null) {
        return null;
      }
      if (typeIsArray(feature_info.code)) {
        return feature_info.code[Math.floor(ROT.RNG.getUniform() * feature_info.code.length)];
      } else {
        return feature_info.code;
      }
    };

    Feature.prototype.getColor = function() {
      var i;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = [0, 1, 2];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _results.push(Math.floor(this.color[i] * this.intensity));
        }
        return _results;
      }).call(this);
    };

    return Feature;

  })(Brew.Thing);

  window.Brew.Item = (function(_super) {
    __extends(Item, _super);

    function Item(item_info) {
      var param, value, _ref, _ref1, _ref2, _ref3;
      Item.__super__.constructor.call(this, "item");
      this.group = (_ref = item_info.group) != null ? _ref : item_info.name;
      this.code = Brew.group[this.group].code;
      this.bgcolor = (_ref1 = item_info.bgcolor) != null ? _ref1 : [0, 0, 0];
      this.damage = (_ref2 = item_info.damage) != null ? _ref2 : 0;
      for (param in item_info) {
        if (!__hasProp.call(item_info, param)) continue;
        value = item_info[param];
        if (this[param] != null) {
          continue;
        }
        this[param] = value;
      }
      this.flags = (_ref3 = item_info.flags) != null ? _ref3 : this.flags;
    }

    return Item;

  })(Brew.Thing);

  inventory_key_list = (function() {
    var _i, _results;
    _results = [];
    for (x = _i = 65; _i <= 81; x = ++_i) {
      _results.push(String.fromCharCode(x));
    }
    return _results;
  })();

  window.Brew.Inventory = (function() {
    function Inventory(max_items) {
      this.items = {};
      this.max_items = max_items != null ? max_items : 16;
      if (this.max_items > inventory_key_list.length) {
        throw "not enough inventory keys";
      }
      this.equipped = {};
    }

    Inventory.prototype.getItems = function() {
      var item, key;
      return (function() {
        var _ref, _results;
        _ref = this.items;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          item = _ref[key];
          _results.push(item);
        }
        return _results;
      }).call(this);
    };

    Inventory.prototype.getKeys = function() {
      var item, key;
      return (function() {
        var _ref, _results;
        _ref = this.items;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          item = _ref[key];
          _results.push(key);
        }
        return _results;
      }).call(this);
    };

    Inventory.prototype.addItem = function(new_item) {
      var next_key;
      if (this.getItems().length === this.max_items) {
        return null;
      } else {
        next_key = this.getNextKey();
        new_item.inv_key = next_key;
        new_item.inv_key_lower = String.fromCharCode(next_key.charCodeAt(0) + 32);
        this.items[next_key] = new_item;
      }
      return next_key;
    };

    Inventory.prototype.removeItemByKey = function(inv_key) {
      var item;
      item = this.items[inv_key];
      item.inv_key = null;
      item.inv_key_lower = null;
      item.equip = null;
      delete this.items[inv_key];
      return true;
    };

    Inventory.prototype.getNextKey = function() {
      var existing_keys, key, _i, _len;
      existing_keys = this.getKeys();
      for (_i = 0, _len = inventory_key_list.length; _i < _len; _i++) {
        key = inventory_key_list[_i];
        if (__indexOf.call(existing_keys, key) < 0) {
          return key;
        }
      }
      throw "unable to generate new inventory key";
      return null;
    };

    Inventory.prototype.getItem = function(inv_key) {
      return this.items[inv_key];
    };

    Inventory.prototype.hasItem = function(item) {
      var i, _ref;
      return _ref = item.id, __indexOf.call((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.getItems();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(i.id);
        }
        return _results;
      }).call(this), _ref) >= 0;
    };

    Inventory.prototype.equipItem = function(item, equip_slot) {
      var i, _ref;
      if (_ref = !item.id, __indexOf.call((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.getItems;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(i.id);
        }
        return _results;
      }).call(this), _ref) >= 0) {
        throw "equipping item not in this inventory!";
      }
      if (!equip_slot in Brew.equip_slot) {
        throw "invalid equip slot " + equip_slot;
      }
      item.equip = equip_slot;
      return true;
    };

    Inventory.prototype.getEquipped = function(equip_slot) {
      var item, key, p;
      p = (function() {
        var _ref, _results;
        _ref = this.items;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          item = _ref[key];
          if ((item != null ? item.equip : void 0) === equip_slot) {
            _results.push(item);
          }
        }
        return _results;
      }).call(this);
      if (p.length === 0) {
        return null;
      } else if (p.length > 1) {
        throw "more than 1 item for given equip slot " + equip_slot;
      } else {
        return p[0];
      }
    };

    Inventory.prototype.unequipItem = function(item) {
      if (item.equip == null) {
        throw "item was not equipped";
      }
      item.equip = null;
      return true;
    };

    return Inventory;

  })();

  window.Brew.Horde = (function() {
    function Horde(monsters) {
      this.monsters = monsters;
      this.id = idGenerator();
    }

    Horde.prototype.updateAll = function(last_player_xy) {
      var m, _i, _len, _ref;
      _ref = this.monsters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        m.last_player_xy = last_player_xy;
      }
      return true;
    };

    Horde.prototype.add = function(mob) {
      mob.horde = this;
      this.monsters.push(mob);
      return true;
    };

    Horde.prototype.hasKnowledgeOf = function(something) {
      var m, _i, _len, _ref;
      _ref = this.monsters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        if (m.hasKnowledgeOf(something)) {
          return true;
        }
      }
      return false;
    };

    return Horde;

  })();


  /*
  stats -
   */

  window.Brew.Stat = (function() {
    function Stat(name, value) {
      this.name = name;
      this.current = value;
      this.max = value;
    }

    Stat.prototype.getCurrent = function() {
      return this.current;
    };

    Stat.prototype.getMax = function() {
      return this.max;
    };

    Stat.prototype.isZero = function() {
      return this.current <= 0;
    };

    Stat.prototype.isMax = function() {
      return this.current === this.max;
    };

    Stat.prototype.addTo = function(amount) {
      this.current = Math.min(this.max, this.current + amount);
      return true;
    };

    Stat.prototype.deduct = function(amount) {
      this.current = Math.max(0, this.current - amount);
      return true;
    };

    Stat.prototype.setTo = function(amount) {
      this.current = amount;
      return true;
    };

    Stat.prototype.addToMax = function(amount) {
      this.current += 1;
      this.max += 1;
      return true;
    };

    Stat.prototype.reset = function() {
      this.current = this.max;
      return true;
    };

    Stat.prototype.deductOverflow = function(amount) {
      var overflow;
      if (amount <= this.current) {
        this.deduct(amount);
        return 0;
      } else {
        overflow = amount - this.current;
        this.current = 0;
        return overflow;
      }
    };

    return Stat;

  })();

  window.Brew.Monster = (function(_super) {
    __extends(Monster, _super);

    function Monster(monster_info) {
      var param, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      Monster.__super__.constructor.call(this, "monster");
      this.fov = {};
      this.knowledge = [];
      this.memory = {};
      this.pathmaps = {};
      this.inventory = new Brew.Inventory();
      this.status = (_ref = monster_info.status) != null ? _ref : Brew.monster_status.SLEEP;
      this.rank = (_ref1 = monster_info.rank) != null ? _ref1 : 0;
      this.damage = (_ref2 = monster_info.damage) != null ? _ref2 : 1;
      this.horde = (_ref3 = monster_info.horde) != null ? _ref3 : null;
      this.attack_range = (_ref4 = monster_info.attack_range) != null ? _ref4 : 1;
      this.agent = (_ref5 = monster_info.agent) != null ? _ref5 : false;
      this.abilities = [];
      this.active_ability = null;
      this.group = (_ref6 = monster_info.group) != null ? _ref6 : monster_info.name;
      this.bgcolor = (_ref7 = monster_info.bgcolor) != null ? _ref7 : [0, 0, 0];
      for (param in monster_info) {
        if (!__hasProp.call(monster_info, param)) continue;
        value = monster_info[param];
        if (this[param] != null) {
          continue;
        }
        this[param] = value;
      }
      this.flags = (_ref8 = monster_info.flags) != null ? _ref8 : this.flags;
    }

    Monster.prototype.getAbilities = function() {
      return this.abilities;
    };

    Monster.prototype.hasAbility = function(ability) {
      return __indexOf.call(this.abilities, ability) >= 0;
    };

    Monster.prototype.addAbility = function(ability) {
      if (!this.hasAbility(ability)) {
        this.abilities.push(ability);
      }
      return true;
    };

    Monster.prototype.removeAbility = function(ability) {
      if (this.hasAbility(ability)) {
        this.abilities.remove(ability);
        return true;
      } else {
        return false;
      }
    };

    Monster.prototype.getAttackRange = function() {
      return this.attack_range;
    };

    Monster.prototype.getAttackDamage = function(is_melee) {
      var _ref;
      return (_ref = this.damage) != null ? _ref : 0;
    };

    Monster.prototype.setMemoryAt = function(level_id, xy, something) {
      if (!(level_id in this.memory)) {
        this.memory[level_id] = {};
      }
      this.memory[level_id][xy.toKey()] = something;
      return true;
    };

    Monster.prototype.getMemoryAt = function(level_id, xy) {
      var _ref;
      if (this.memory[level_id] != null) {
        return (_ref = this.memory[level_id][xy.toKey()]) != null ? _ref : null;
      } else {
        return null;
      }
    };

    Monster.prototype.canView = function(xy) {
      if (this.hasFlag(Brew.flags.see_all)) {
        return true;
      } else {
        return xy.toKey() in this.fov;
      }
    };

    Monster.prototype.clearFov = function() {
      this.fov = {};
      return true;
    };

    Monster.prototype.clearKnowledge = function() {
      this.knowledge = [];
      return true;
    };

    Monster.prototype.setFovAt = function(level, xy) {
      this.fov[xy.toKey()] = true;
      this.updateKnowledgeAt(level, xy);
      return true;
    };

    Monster.prototype.updateKnowledgeAt = function(level, xy) {
      var item, mob;
      if (xy.compare(this.coordinates)) {
        return true;
      }
      item = level.getItemAt(xy);
      if (item != null) {
        this.knowledge.push(item.id);
      }
      mob = level.getMonsterAt(xy);
      if ((mob != null) && !mob.hasFlag(Brew.flags.invisible)) {
        if (this.group !== "player" && mob.group === "player") {
          this.last_player_xy = xy;
          if (this.horde != null) {
            this.horde.updateAll(xy);
          }
        }
        this.knowledge.push(mob.id);
      }
      return true;
    };

    Monster.prototype.hasKnowledgeOf = function(thing) {
      var _ref;
      return _ref = thing.id, __indexOf.call(this.knowledge, _ref) >= 0;
    };

    Monster.prototype.updateFov = function(ye_level) {
      var fn_allow_vision, fn_update_fov, my_x, my_y, rot_fov;
      this.clearFov();
      this.clearKnowledge();
      my_x = this.coordinates.x;
      my_y = this.coordinates.y;
      fn_allow_vision = function(x, y) {
        if (x < 0 || x >= ye_level.width || y < 0 || y >= ye_level.height) {
          return false;
        } else if (x === my_x && y === my_y) {
          return true;
        } else {
          return !ye_level.checkBlocksVision(new Coordinate(x, y));
        }
      };
      fn_update_fov = (function(_this) {
        return function(x, y, r, visibility) {
          _this.setFovAt(ye_level, new Coordinate(x, y));
          return true;
        };
      })(this);
      rot_fov = new ROT.FOV.PreciseShadowcasting(fn_allow_vision);
      rot_fov.compute(this.coordinates.x, this.coordinates.y, 9, fn_update_fov);
      return true;
    };

    return Monster;

  })(Brew.Thing);

  window.Brew.Level = (function() {
    function Level(depth, width, height, options) {
      var _ref;
      this.depth = depth;
      this.width = width;
      this.height = height;
      this.id = idGenerator();
      this.terrain = {};
      this.features = {};
      this.overheads = {};
      this.monsters = {};
      this.items = {};
      this.light = {};
      this.portals = {};
      this.agents = {};
      this.ambient_light = (_ref = options != null ? options.ambient_light : void 0) != null ? _ref : [130, 130, 130];
      this.navigation = {};
    }

    Level.prototype.updateLightMap = function() {
      var fn_allow_vision, fn_reflectivity, fn_update_light, key, light, light_range, lighting, lightsources, monster, overhead, rot_fov, t, xy, _i, _len, _ref, _ref1, _ref2;
      this.light = {};
      lightsources = [];
      _ref = this.monsters;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        monster = _ref[key];
        if (monster.light_source != null) {
          lightsources.push({
            center: monster.coordinates,
            color: monster.light_source
          });
        }
      }
      _ref1 = this.overheads;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        overhead = _ref1[key];
        if (overhead.light_source != null) {
          xy = keyToCoord(key);
          lightsources.push({
            center: xy,
            color: overhead.light_source
          });
        }
      }
      _ref2 = this.terrain;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        t = _ref2[key];
        if (t.light_source != null) {
          xy = keyToCoord(key);
          lightsources.push({
            center: xy,
            color: t.light_source
          });
        }
      }
      fn_allow_vision = (function(_this) {
        return function(x, y) {
          if (x < 0 || x >= _this.width || y < 0 || y >= _this.height) {
            return false;
          } else {
            return !_this.checkBlocksVision(new Coordinate(x, y));
          }
        };
      })(this);
      fn_update_light = (function(_this) {
        return function(x, y, color) {
          return _this.setLightAt(new Coordinate(x, y), color);
        };
      })(this);
      fn_reflectivity = (function(_this) {
        return function(x, y) {
          return 0;
        };
      })(this);
      light_range = Math.max(this.width, this.height);
      rot_fov = new ROT.FOV.PreciseShadowcasting(fn_allow_vision);
      lighting = new ROT.Lighting(fn_reflectivity, {
        range: light_range,
        passes: 2
      });
      lighting.setFOV(rot_fov);
      for (_i = 0, _len = lightsources.length; _i < _len; _i++) {
        light = lightsources[_i];
        lighting.setLight(light.center.x, light.center.y, light.color);
      }
      lighting.compute(fn_update_light);
      return true;
    };

    Level.prototype.checkValid = function(xy) {
      var is_valid;
      is_valid = xy.x >= 0 && xy.x < this.width && xy.y >= 0 && xy.y < this.height;
      return is_valid;
    };

    Level.prototype.checkBlocksVision = function(xy) {
      var t;
      t = this.getTerrainAt(xy);
      if (t == null) {
        debugger;
      }
      return t.blocks_vision;
    };

    Level.prototype.setTerrainAt = function(xy, terrain) {
      var existing_terrain, key;
      key = xy.toKey();
      existing_terrain = this.terrain[key];
      if (existing_terrain != null) {
        this.calcTerrainNavigation();
      }
      terrain.coordinates = xy;
      this.terrain[key] = terrain;
      return true;
    };

    Level.prototype.getTerrain = function() {
      return this.terrain;
    };

    Level.prototype.getTerrainAt = function(xy) {
      return this.terrain[xy.toKey()];
    };

    Level.prototype.calcTerrainNavigation = function() {
      var canFly, canWalk, key, terrain, y, _i, _j, _ref, _ref1;
      this.navigation = {
        walk: {
          xy: [],
          key: []
        },
        fly: {
          xy: [],
          key: []
        }
      };
      for (x = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          key = keyFromXY(x, y);
          terrain = this.terrain[key];
          canWalk = (!terrain.blocks_walking) || (terrain.blocks_walking && (terrain.can_open != null) && terrain.can_open);
          canFly = canWalk || (!terrain.blocks_flying);
          if (canWalk) {
            this.navigation.walk.xy.push(keyToCoord(key));
            this.navigation.walk.key.push(Number(key));
          }
          if (canFly) {
            this.navigation.fly.xy.push(keyToCoord(key));
            this.navigation.fly.key.push(Number(key));
          }
        }
      }
      return true;
    };

    Level.prototype.getRandomWalkableLocation = function() {
      var index, tries, xy;
      tries = 0;
      while (tries < 50) {
        index = Math.floor(ROT.RNG.getUniform() * this.navigation.walk.xy.length);
        xy = this.navigation.walk.xy[index];
        if (this.getMonsterAt(xy) != null) {
          tries += 1;
          continue;
        }
        if (this.getTerrainAt(xy).blocks_vision) {
          tries += 1;
          continue;
        }
        if ((this.start_xy != null) && xy.compare(this.start_xy)) {
          tries += 1;
          continue;
        }
        if ((this.exit_xy != null) && xy.compare(this.exit_xy)) {
          tries += 1;
          continue;
        }
        return xy;
      }
      console.error("getRandomWalkableLocation failed ", tries);
      return null;
    };

    Level.prototype.getRandomWalkableLocationNear = function(center_xy, distance) {
      var bottom, i, left, m, possible_lst, right, t, top, xy, y, _i, _j;
      right = center_xy.x - Math.floor(distance / 2);
      top = center_xy.y - Math.floor(distance / 2);
      left = center_xy.x + Math.floor(distance / 2);
      bottom = center_xy.y + Math.floor(distance / 2);
      possible_lst = [];
      for (x = _i = right; right <= left ? _i <= left : _i >= left; x = right <= left ? ++_i : --_i) {
        for (y = _j = top; top <= bottom ? _j <= bottom : _j >= bottom; y = top <= bottom ? ++_j : --_j) {
          xy = new Coordinate(x, y);
          if (xy.compare(center_xy)) {
            continue;
          }
          t = this.getTerrainAt(xy);
          if (t == null) {
            continue;
          }
          if (t.blocks_walking) {
            continue;
          }
          i = this.getItemAt(xy);
          if (i != null) {
            continue;
          }
          m = this.getMonsterAt(xy);
          if (m != null) {
            continue;
          }
          possible_lst.push(xy);
        }
      }
      if (possible_lst.length === 0) {
        return null;
      } else {
        return possible_lst.random();
      }
    };

    Level.prototype.setMonsterAt = function(xy, mob_or_newt) {
      this.monsters[xy.toKey()] = mob_or_newt;
      mob_or_newt.setLocation(xy);
      return true;
    };

    Level.prototype.removeMonsterAt = function(xy) {
      delete this.monsters[xy.toKey()];
      return true;
    };

    Level.prototype.getMonsterAt = function(xy) {
      if (xy == null) {
        debugger;
      }
      return this.monsters[xy.toKey()];
    };

    Level.prototype.getMonsters = function() {
      var key, mob;
      return (function() {
        var _ref, _results;
        _ref = this.monsters;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          mob = _ref[key];
          _results.push(mob);
        }
        return _results;
      }).call(this);
    };

    Level.prototype.getMonsterById = function(id) {
      var id_list, idx, m, monsters;
      monsters = this.getMonsters();
      id_list = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = monsters.length; _i < _len; _i++) {
          m = monsters[_i];
          _results.push(m.id);
        }
        return _results;
      })();
      idx = id_list.indexOf(id);
      if (idx === -1) {
        return null;
      } else {
        return monsters[idx];
      }
    };

    Level.prototype.setItemAt = function(xy, item) {
      this.items[xy.toKey()] = item;
      item.setLocation(xy);
      return true;
    };

    Level.prototype.removeItemAt = function(xy) {
      delete this.items[xy.toKey()];
      return true;
    };

    Level.prototype.getItemAt = function(xy) {
      return this.items[xy.toKey()];
    };

    Level.prototype.getItems = function() {
      var item, key;
      return (function() {
        var _ref, _results;
        _ref = this.items;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          item = _ref[key];
          _results.push(item);
        }
        return _results;
      }).call(this);
    };

    Level.prototype.setLightAt = function(xy, color) {
      this.light[xy.toKey()] = ROT.Color.add(color, this.ambient_light);
      return true;
    };

    Level.prototype.getLightAt = function(xy) {
      var light_at;
      light_at = this.light[xy.toKey()];
      return light_at != null ? light_at : this.ambient_light;
    };

    Level.prototype.getLightAt_NoAmbient = function(xy) {
      return this.light[xy.toKey()];
    };

    Level.prototype.clearLights = function() {
      this.light = {};
      return true;
    };

    Level.prototype.setUnlinkedPortalAt = function(xy) {
      return this.portals[xy.toKey()] = new Portal();
    };

    Level.prototype.setLinkedPortalAt = function(xy, to_level_id, to_level_xy) {
      return this.portals[xy.toKey()] = new Portal(to_level_id, to_level_xy);
    };

    Level.prototype.getPortalAt = function(xy) {
      return this.portals[xy.toKey()];
    };

    Level.prototype.setFeatureAt = function(xy, thing) {
      this.features[xy.toKey()] = thing;
      thing.setLocation(xy);
      return true;
    };

    Level.prototype.removeFeatureAt = function(xy) {
      delete this.features[xy.toKey()];
      return true;
    };

    Level.prototype.getFeatureAt = function(xy) {
      return this.features[xy.toKey()];
    };

    Level.prototype.getFeatures = function() {
      var f, key;
      return (function() {
        var _ref, _results;
        _ref = this.features;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          f = _ref[key];
          _results.push(f);
        }
        return _results;
      }).call(this);
    };

    Level.prototype.setOverheadAt = function(xy, thing) {
      this.overheads[xy.toKey()] = thing;
      thing.setLocation(xy);
      return true;
    };

    Level.prototype.removeOverheadAt = function(xy) {
      delete this.overheads[xy.toKey()];
      return true;
    };

    Level.prototype.getOverheadAt = function(xy) {
      return this.overheads[xy.toKey()];
    };

    Level.prototype.getOverheads = function() {
      var f, key;
      return (function() {
        var _ref, _results;
        _ref = this.overheads;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          f = _ref[key];
          _results.push(f);
        }
        return _results;
      }).call(this);
    };

    Level.prototype.setAgentAt = function(xy, agent) {
      this.agents[xy.toKey()] = agent;
      agent.setLocation(xy);
      return true;
    };

    Level.prototype.removeAgentAt = function(xy) {
      delete this.agents[xy.toKey()];
      return true;
    };

    Level.prototype.getAgentAt = function(xy) {
      if (xy == null) {
        debugger;
      }
      return this.agents[xy.toKey()];
    };

    Level.prototype.getAgents = function() {
      var a, key;
      return (function() {
        var _ref, _results;
        _ref = this.agents;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          a = _ref[key];
          _results.push(a);
        }
        return _results;
      }).call(this);
    };

    return Level;

  })();

  Portal = (function() {
    function Portal(to_level_id, level_xy) {
      this.to_level_id = to_level_id != null ? to_level_id : -1;
      this.level_xy = level_xy != null ? level_xy : null;
    }

    return Portal;

  })();

}).call(this);

//# sourceMappingURL=objects.map
