// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Brew.Animation = (function(_super) {
    __extends(Animation, _super);

    function Animation(animation_type) {
      Animation.__super__.constructor.call(this, "animation");
      this.animationType = animation_type;
      this.turn = 0;
      this.active = true;
      this.over_saturate = false;
    }

    Animation.prototype.runTurn = function(game, ui, level) {
      this.cleanup(game, ui, level);
      this.turn += 1;
      return this.update(game, ui, level);
    };

    Animation.prototype.getSpeed = function() {
      return 10000;
    };

    return Animation;

  })(Brew.Thing);

  window.Brew.FlashAnimation = (function(_super) {
    __extends(FlashAnimation, _super);

    function FlashAnimation(flash_xy, flash_color) {
      this.flash_xy = flash_xy;
      this.flash_color = flash_color;
      FlashAnimation.__super__.constructor.call(this, "flash");
      this.lastOverhead = null;
    }

    FlashAnimation.prototype.cleanup = function(game, ui, level) {
      if (this.turn === 1) {
        if (this.lastOverhead != null) {
          level.setOverheadAt(this.flash_xy, this.lastOverhead);
        } else {
          level.removeOverheadAt(this.flash_xy);
        }
        return ui.drawMapAt(this.flash_xy);
      }
    };

    FlashAnimation.prototype.update = function(game, ui, level) {
      var flash, overhead;
      if (this.turn === 1) {
        overhead = level.getOverheadAt(this.flash_xy);
        if (overhead != null) {
          this.lastOverhead = overhead;
        }
        flash = Brew.featureFactory("TILE_FLASH", {
          color: this.flash_color
        });
        level.setOverheadAt(this.flash_xy, flash);
        return ui.drawMapAt(this.flash_xy);
      } else {
        return this.active = false;
      }
    };

    return FlashAnimation;

  })(Brew.Animation);

  window.Brew.LaserAnimation = (function(_super) {
    __extends(LaserAnimation, _super);

    function LaserAnimation(attacker, projectile_thing, full_path_lst) {
      this.attacker = attacker;
      this.projectile_thing = projectile_thing;
      this.full_path_lst = full_path_lst;
      LaserAnimation.__super__.constructor.call(this, "laser");
      this.lastOverhead = null;
      this.over_saturate = true;
    }

    LaserAnimation.prototype.cleanup = function(game, ui, level) {
      var idx, last_xy;
      if (this.turn === 0) {
        return;
      }
      idx = this.turn - 1;
      if (idx >= this.full_path_lst.length) {
        console.log("tried to clean up bad index " + idx);
        return;
      }
      last_xy = this.full_path_lst[idx];
      if (this.lastOverhead != null) {
        level.setOverheadAt(last_xy, this.lastOverhead);
      } else {
        level.removeOverheadAt(last_xy);
      }
      ui.drawMapAt(last_xy);
      return this.lastOverhead = null;
    };

    LaserAnimation.prototype.update = function(game, ui, level) {
      var idx, next_xy, overhead, target;
      idx = this.turn - 1;
      if (idx === this.full_path_lst.length) {
        console.log("error, index too high on pathing animation");
        this.active = false;
        return;
      }
      next_xy = this.full_path_lst[idx];
      if (idx === this.full_path_lst.length - 1) {
        this.active = false;
        target = level.getMonsterAt(next_xy);
        return game.attack(this.attacker, target, false, {
          remote: this.projectile_thing
        });
      } else {
        overhead = level.getOverheadAt(next_xy);
        if (overhead != null) {
          this.lastOverhead = overhead;
        }
        level.setOverheadAt(next_xy, this.projectile_thing);
        return ui.drawMapAt(next_xy);
      }
    };

    return LaserAnimation;

  })(Brew.Animation);

  window.Brew.ThrownAnimation = (function(_super) {
    __extends(ThrownAnimation, _super);

    function ThrownAnimation(thrower, thrown_item, full_path_lst) {
      this.thrower = thrower;
      this.thrown_item = thrown_item;
      this.full_path_lst = full_path_lst;
      ThrownAnimation.__super__.constructor.call(this, "thrown");
      this.lastOverhead = null;
    }

    ThrownAnimation.prototype.cleanup = function(game, ui, level) {
      var idx, last_xy;
      if (this.turn === 0) {
        return;
      }
      idx = this.turn - 1;
      if (idx >= this.full_path_lst.length) {
        console.log("tried to clean up bad index " + idx);
        return;
      }
      last_xy = this.full_path_lst[idx];
      if (this.lastOverhead != null) {
        level.setOverheadAt(last_xy, this.lastOverhead);
      } else {
        level.removeOverheadAt(last_xy);
      }
      ui.drawMapAt(last_xy);
      return this.lastOverhead = null;
    };

    ThrownAnimation.prototype.update = function(game, ui, level) {
      var idx, next_xy, overhead;
      idx = this.turn - 1;
      if (idx === this.full_path_lst.length) {
        console.log("error, index too high on pathing animation");
        this.active = false;
        return;
      }
      next_xy = this.full_path_lst[idx];
      if (idx === this.full_path_lst.length - 1) {
        this.active = false;
        level.setItemAt(next_xy, this.thrown_item);
      } else {
        overhead = level.getOverheadAt(next_xy);
        if (overhead != null) {
          this.lastOverhead = overhead;
        }
        level.setOverheadAt(next_xy, this.thrown_item);
      }
      return ui.drawMapAt(next_xy);
    };

    return ThrownAnimation;

  })(Brew.Animation);

  window.Brew.FireballAnimation = (function(_super) {
    __extends(FireballAnimation, _super);

    function FireballAnimation(attacker, rocket_item, full_path_lst) {
      this.attacker = attacker;
      this.rocket_item = rocket_item;
      this.full_path_lst = full_path_lst;
      FireballAnimation.__super__.constructor.call(this, "fireball");
      this.overhead_cache = {};
      this.over_saturate = true;
      this.rocket_item.light_source = Brew.colors.orange;
      this.trail_feature = "PROJ_FIREBALL_TRAIL";
    }

    FireballAnimation.prototype.cleanup = function(game, ui, level) {
      var idx, last_xy;
      if (this.turn === 0) {
        return;
      }
      idx = this.turn - 1;
      if (idx >= this.full_path_lst.length) {
        console.log("tried to clean up bad index " + idx);
        return;
      }
      last_xy = this.full_path_lst[idx];
      level.setOverheadAt(last_xy, Brew.featureFactory(this.trail_feature));
      ui.drawMapAt(last_xy);
      return this.lastOverhead = null;
    };

    FireballAnimation.prototype.update = function(game, ui, level) {
      var idx, next_xy, overhead, target;
      idx = this.turn - 1;
      if (idx === this.full_path_lst.length) {
        console.log("error, index too high on pathing animation");
        this.active = false;
        return;
      }
      next_xy = this.full_path_lst[idx];
      if (idx === this.full_path_lst.length - 1) {
        this.active = false;
        target = level.getMonsterAt(next_xy);
        this.replaceTrail(game, ui, level);
        return this.impact(game, ui, level, next_xy);
      } else {
        overhead = level.getOverheadAt(next_xy);
        this.overhead_cache[next_xy.toKey()] = overhead;
        level.setOverheadAt(next_xy, this.rocket_item);
        return ui.drawMapAt(next_xy);
      }
    };

    FireballAnimation.prototype.replaceTrail = function(game, ui, level) {
      var cached_overhead, key, xy, _ref, _results;
      _ref = this.overhead_cache;
      _results = [];
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        cached_overhead = _ref[key];
        xy = keyToCoord(key);
        if (cached_overhead != null) {
          _results.push(level.setOverheadAt(xy, cached_overhead));
        } else {
          _results.push(level.removeOverheadAt(xy));
        }
      }
      return _results;
    };

    FireballAnimation.prototype.impact = function(game, ui, level, center_xy) {
      var firey_lst, impact_lst, t, xy, _i, _len;
      firey_lst = center_xy.getSurrounding();
      firey_lst.push(center_xy);
      firey_lst.reverse();
      impact_lst = [];
      for (_i = 0, _len = firey_lst.length; _i < _len; _i++) {
        xy = firey_lst[_i];
        t = level.getTerrainAt(xy);
        if (t.blocks_walking) {
          continue;
        }
        impact_lst.push(xy);
      }
      return game.addAnimation(new Brew.ImpactAnimation(impact_lst, this.rocket_item.color, this.attacker, this.rocket_item));
    };

    return FireballAnimation;

  })(Brew.Animation);

  window.Brew.ShinyAnimation = (function(_super) {
    __extends(ShinyAnimation, _super);

    function ShinyAnimation(target, shine_color) {
      this.target = target;
      this.shine_color = shine_color;
      ShinyAnimation.__super__.constructor.call(this, "shiny");
      this.oldcolor = this.target.light_source;
      this.over_saturate = true;
    }

    ShinyAnimation.prototype.cleanup = function(game, ui, level) {
      if (this.turn === 1) {
        return this.target.light_source = this.oldcolor;
      }
    };

    ShinyAnimation.prototype.update = function(game, ui, level) {
      if (this.turn === 1) {
        return this.target.light_source = this.shine_color;
      } else {
        return this.active = false;
      }
    };

    return ShinyAnimation;

  })(Brew.Animation);

  window.Brew.CircleAnimation = (function(_super) {
    __extends(CircleAnimation, _super);

    function CircleAnimation(center_xy, max_radius, circle_color) {
      this.center_xy = center_xy;
      this.max_radius = max_radius;
      this.circle_color = circle_color;
      CircleAnimation.__super__.constructor.call(this, "circle");
      this.overhead_cache = {};
      this.over_saturate = false;
    }

    CircleAnimation.prototype.getPoints = function(game, ui, level) {
      var circle_lst, points_lst, t, xy, _i, _len;
      circle_lst = Brew.utils.getCirclePoints(this.center_xy, this.turn);
      points_lst = [];
      for (_i = 0, _len = circle_lst.length; _i < _len; _i++) {
        xy = circle_lst[_i];
        if (!level.checkValid(xy)) {
          continue;
        }
        t = level.getTerrainAt(xy);
        if (t.blocks_walking && t.blocks_flying) {
          continue;
        }
        points_lst.push(xy);
      }
      return points_lst;
    };

    CircleAnimation.prototype.cleanup = function(game, ui, level) {
      var cached_overhead, xy, _i, _len, _ref, _results;
      if (this.turn === 0) {
        return;
      }
      _ref = this.getPoints(game, ui, level);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        xy = _ref[_i];
        cached_overhead = this.overhead_cache[xy.toKey()];
        if (cached_overhead != null) {
          level.setOverheadAt(xy, cached_overhead);
        } else {
          level.removeOverheadAt(xy);
        }
        _results.push(ui.drawMapAt(xy));
      }
      return _results;
    };

    CircleAnimation.prototype.update = function(game, ui, level) {
      var existing_overhead, flash, xy, _i, _len, _ref, _results;
      if (this.turn > this.max_radius) {
        this.active = false;
        return;
      }
      _ref = this.getPoints(game, ui, level);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        xy = _ref[_i];
        existing_overhead = level.getOverheadAt(xy);
        if ((existing_overhead != null) && Brew.utils.compareDef(existing_overhead, "TILE_FLASH")) {
          continue;
        } else {
          this.overhead_cache[xy.toKey()] = existing_overhead;
          flash = Brew.featureFactory("TILE_FLASH", {
            color: this.circle_color
          });
          level.setOverheadAt(xy, flash);
          _results.push(ui.drawMapAt(xy));
        }
      }
      return _results;
    };

    return CircleAnimation;

  })(Brew.Animation);

  window.Brew.ChargeAnimation = (function(_super) {
    __extends(ChargeAnimation, _super);

    function ChargeAnimation(charger, projectile_thing, full_path_lst, target) {
      this.charger = charger;
      this.projectile_thing = projectile_thing;
      this.full_path_lst = full_path_lst;
      this.target = target;
      ChargeAnimation.__super__.constructor.call(this, "charge");
      this.lastOverhead = null;
    }

    ChargeAnimation.prototype.cleanup = function(game, ui, level) {
      var idx, last_xy;
      if (this.turn === 0) {
        return;
      }
      idx = this.turn - 1;
      if (idx >= this.full_path_lst.length) {
        console.log("tried to clean up bad index " + idx);
        return;
      }
      last_xy = this.full_path_lst[idx];
      if (this.lastOverhead != null) {
        level.setOverheadAt(last_xy, this.lastOverhead);
      } else {
        level.removeOverheadAt(last_xy);
      }
      ui.drawMapAt(last_xy);
      return this.lastOverhead = null;
    };

    ChargeAnimation.prototype.update = function(game, ui, level) {
      var idx, next_xy, old_xy, overhead;
      idx = this.turn - 1;
      if (idx === this.full_path_lst.length) {
        console.log("error, index too high on pathing animation");
        this.active = false;
        return;
      }
      next_xy = this.full_path_lst[idx];
      if (idx === this.full_path_lst.length - 1) {
        this.active = false;
        old_xy = clone(this.charger.coordinates);
        level.removeMonsterAt(old_xy);
        level.setMonsterAt(next_xy, this.charger);
        ui.drawMapAt(old_xy);
        game.attack(this.charger, this.target, true, {
          charge: true
        });
      } else {
        overhead = level.getOverheadAt(next_xy);
        if (overhead != null) {
          this.lastOverhead = overhead;
        }
        level.setOverheadAt(next_xy, this.projectile_thing);
      }
      return ui.drawMapAt(next_xy);
    };

    return ChargeAnimation;

  })(Brew.Animation);

  window.Brew.ImpactAnimation = (function(_super) {
    __extends(ImpactAnimation, _super);

    function ImpactAnimation(impact_xy_lst, flash_color, attacker, weapon) {
      this.impact_xy_lst = impact_xy_lst;
      this.flash_color = flash_color;
      this.attacker = attacker;
      this.weapon = weapon;
      ImpactAnimation.__super__.constructor.call(this, "flash");
      this.overhead_cache = {};
    }

    ImpactAnimation.prototype.cleanup = function(game, ui, level) {
      var cached_overhead, xy, _i, _len, _ref, _results;
      if (this.turn === 1) {
        _ref = this.impact_xy_lst;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xy = _ref[_i];
          cached_overhead = this.overhead_cache[xy.toKey()];
          if (cached_overhead != null) {
            level.setOverheadAt(xy, cached_overhead);
          } else {
            level.removeOverheadAt(xy);
          }
          ui.drawMapAt(xy);
          _results.push(game.remoteImpact(this.attacker, xy, this.weapon));
        }
        return _results;
      }
    };

    ImpactAnimation.prototype.update = function(game, ui, level) {
      var existing_overhead, flash, xy, _i, _len, _ref, _results;
      if (this.turn === 1) {
        _ref = this.impact_xy_lst;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xy = _ref[_i];
          existing_overhead = level.getOverheadAt(xy);
          if ((existing_overhead != null) && Brew.utils.compareDef(existing_overhead, "TILE_FLASH")) {
            continue;
          } else {
            this.overhead_cache[xy.toKey()] = existing_overhead;
            flash = Brew.featureFactory("TILE_FLASH", {
              color: this.flash_color
            });
            level.setOverheadAt(xy, flash);
            _results.push(ui.drawMapAt(xy));
          }
        }
        return _results;
      } else {
        return this.active = false;
      }
    };

    return ImpactAnimation;

  })(Brew.Animation);

  window.Brew.ProjectileAnimation = (function(_super) {
    __extends(ProjectileAnimation, _super);

    function ProjectileAnimation(attacker, projectile_thing, full_path_lst) {
      this.attacker = attacker;
      this.projectile_thing = projectile_thing;
      this.full_path_lst = full_path_lst;
      ProjectileAnimation.__super__.constructor.call(this, "projectile");
      this.lastOverhead = null;
    }

    ProjectileAnimation.prototype.cleanup = function(game, ui, level) {
      var idx, last_xy;
      if (this.turn === 0) {
        return;
      }
      idx = this.turn - 1;
      if (idx >= this.full_path_lst.length) {
        console.log("tried to clean up bad index " + idx);
        return;
      }
      last_xy = this.full_path_lst[idx];
      if (this.lastOverhead != null) {
        level.setOverheadAt(last_xy, this.lastOverhead);
      } else {
        level.removeOverheadAt(last_xy);
      }
      ui.drawMapAt(last_xy);
      return this.lastOverhead = null;
    };

    ProjectileAnimation.prototype.update = function(game, ui, level) {
      var idx, next_xy, overhead, target;
      idx = this.turn - 1;
      if (idx === this.full_path_lst.length) {
        console.log("error, index too high on pathing animation");
        this.active = false;
        return;
      }
      next_xy = this.full_path_lst[idx];
      if (idx === this.full_path_lst.length - 1) {
        this.active = false;
        target = level.getMonsterAt(next_xy);
        return game.attack(this.attacker, target, false, {
          remote: this.projectile_thing
        });
      } else {
        overhead = level.getOverheadAt(next_xy);
        if (overhead != null) {
          this.lastOverhead = overhead;
        }
        level.setOverheadAt(next_xy, this.projectile_thing);
        return ui.drawMapAt(next_xy);
      }
    };

    return ProjectileAnimation;

  })(Brew.Animation);

}).call(this);

//# sourceMappingURL=animation.map
