// Generated by CoffeeScript 1.7.1
(function() {
  window.Brew.AbilityCode = (function() {
    function AbilityCode(game) {
      this.game = game;
      true;
    }

    AbilityCode.prototype.gameLevel = function() {
      return this.game.my_level;
    };

    AbilityCode.prototype.gamePlayer = function() {
      return this.game.my_player;
    };

    AbilityCode.prototype.checkUseAt = function(ability, map_xy) {
      return this.canUseAt(ability, map_xy)[0];
    };

    AbilityCode.prototype.checkPairUseAt = function(ability, map_xy) {
      var ability_def, pair_ok;
      ability_def = Brew.ability[ability];
      pair_ok = ability_def.pair;
      return this.canUseAt(ability, map_xy)[0] && pair_ok;
    };

    AbilityCode.prototype.canUseAt = function(ability, map_xy) {
      var can_use, data, _ref;
      _ref = (function() {
        switch (ability) {
          case Brew.abilities.charge:
            return this.charge_canUseAt(map_xy);
          case Brew.abilities.fireball:
            return this.generic_canUseAt(ability, map_xy);
          case Brew.abilities.forcebolt:
            return this.generic_canUseAt(ability, map_xy);
          case Brew.abilities.entangle:
            return this.generic_canUseAt(ability, map_xy);
          case Brew.abilities.banish:
            return this.generic_canUseAt(ability, map_xy);
          case Brew.abilities.warcry:
            return this.generic_canUseAt(ability, map_xy);
          case Brew.abilities.defend:
            return this.generic_canUseAt(ability, map_xy);
          default:
            return console.error("invalid ability " + ability);
        }
      }).call(this), can_use = _ref[0], data = _ref[1];
      return [can_use, data];
    };

    AbilityCode.prototype.execute = function(ability, map_xy, paired) {
      var ability_def, can_use, cost, data, endTurn, player, player_xy, target, xy, _ref, _ref1, _ref2;
      ability_def = Brew.ability[ability];
      if (paired && (!ability_def.pair)) {
        this.game.msg("" + ability_def.name + " does not work across realms.");
        return false;
      }
      _ref = this.canUseAt(ability, map_xy), can_use = _ref[0], data = _ref[1];
      if (!can_use) {
        this.game.msg(data);
        return false;
      }
      if (paired) {
        this.game.socket.sendAbilityClick(this.gamePlayer().coordinates, this.gamePlayer().active_ability, map_xy);
        return true;
      }
      player = this.gamePlayer();
      player_xy = player.coordinates;
      xy = (_ref1 = data.xy) != null ? _ref1 : null;
      target = (_ref2 = data.target) != null ? _ref2 : null;
      endTurn = false;
      endTurn = (function() {
        switch (ability) {
          case Brew.abilities.charge:
            return this.charge_execute(player, player_xy, xy, target);
          case Brew.abilities.banish:
            return this.banish_execute(player, player_xy, xy, target);
          case Brew.abilities.warcry:
            return this.warcry_execute(player, player_xy, xy);
          case Brew.abilities.defend:
            return this.defend_execute(player, player_xy, xy);
          case Brew.abilities.fireball:
            return this.fireball_execute(player, player_xy, xy);
          case Brew.abilities.entangle:
            return this.entangle_execute(player, player_xy, xy);
          case Brew.abilities.forcebolt:
            return this.forcebolt_execute(player, player_xy, xy, target);
          default:
            return console.error("invalid executed ability " + ability);
        }
      }).call(this);
      cost = Brew.ability[ability].cost;
      player.getStat(Brew.stat.stamina).deduct(cost);
      this.game.ui.drawHudAll();
      if (endTurn) {
        return this.game.endPlayerTurn();
      }
    };

    AbilityCode.prototype.charge_canUseAt = function(map_xy) {
      var ability_def, actual_xy, dist2d, has_stamina, i, last_xy, line, m, t, target_mob, xy, _i, _len;
      ability_def = Brew.ability[Brew.abilities.charge];
      dist2d = Brew.utils.dist2d(this.gamePlayer().coordinates, map_xy);
      if (dist2d > ability_def.range) {
        return [false, "Out of range"];
      }
      if (Math.floor(dist2d) <= 1) {
        return [false, "Too close"];
      }
      target_mob = this.gameLevel().getMonsterAt(map_xy);
      if (target_mob == null) {
        return [false, "No target"];
      }
      line = Brew.utils.getLineBetweenPoints(this.gamePlayer().coordinates, map_xy);
      last_xy = null;
      actual_xy = null;
      for (i = _i = 0, _len = line.length; _i < _len; i = ++_i) {
        xy = line[i];
        if (i === 0) {
          last_xy = xy;
          continue;
        }
        t = this.gameLevel().getTerrainAt(xy);
        if (t.blocks_walking) {
          return [false, "Something is in the way"];
        }
        m = this.gameLevel().getMonsterAt(xy);
        if ((m != null) && !Brew.utils.compareThing(m, target_mob)) {
          return [false, "Another target is in the way"];
        }
        if ((m != null) && Brew.utils.compareThing(m, target_mob)) {
          actual_xy = last_xy;
          break;
        }
        last_xy = xy;
      }
      if (actual_xy == null) {
        return [false, "something horrible happened"];
      }
      has_stamina = true;
      if (!has_stamina) {
        return [false, "not enough stamina"];
      }
      return [
        true, {
          "xy": actual_xy,
          "target": target_mob
        }
      ];
    };

    AbilityCode.prototype.charge_execute = function(caster, from_xy, landing_xy, target_monster) {
      var projectile, traverse_lst;
      traverse_lst = Brew.utils.getLineBetweenPoints(from_xy, landing_xy);
      projectile = Brew.featureFactory("PROJ_CHARGE", {
        code: caster.code,
        color: caster.color
      });
      this.game.addAnimation(new Brew.ChargeAnimation(caster, projectile, traverse_lst, target_monster));
      return true;
    };

    AbilityCode.prototype.fireball_execute = function(caster, from_xy, center_xy) {
      var fireball, fireball_damage, traverse_lst;
      traverse_lst = Brew.utils.getLineBetweenPoints(from_xy, center_xy);
      fireball_damage = Math.floor(caster.getStat(Brew.stat.stamina).getMax() / Brew.config.fireball_damage_div);
      fireball = Brew.featureFactory("PROJ_FIREBALL", {
        damage: fireball_damage
      });
      fireball.setFlag(Brew.flags.weapon_burning);
      this.game.addAnimation(new Brew.FireballAnimation(caster, fireball, traverse_lst));
      return true;
    };

    AbilityCode.prototype.forcebolt_execute = function(caster, from_xy, center_xy, target) {
      var bolt, bolt_damage, traverse_lst;
      traverse_lst = Brew.utils.getLineBetweenPoints(from_xy, center_xy);
      bolt_damage = Math.floor(caster.getStat(Brew.stat.stamina).getMax() / Brew.config.forcebolt_damage_div);
      bolt = Brew.featureFactory("PROJ_FORCEBOLT", {
        damage: bolt_damage
      });
      bolt.code = Brew.utils.getLaserProjectileCode(from_xy, center_xy);
      this.game.addAnimation(new Brew.LaserAnimation(caster, bolt, traverse_lst));
      return true;
    };

    AbilityCode.prototype.banish_execute = function(caster, from_xy, center_xy, target) {
      if (target == null) {
        console.error("no target for banish");
        return false;
      }
      if (target.group === "TIME_MASTER") {
        this.game.msg("The Time Master laughs.");
        return false;
      }
      this.game.msg("" + target.name + " fades from your reality!");
      this.game.socket.sendMonster(target);
      this.gameLevel().removeMonsterAt(center_xy);
      this.game.scheduler.remove(target);
      this.game.ui.drawMapAt(center_xy);
      this.game.addAnimation(new Brew.ShinyAnimation(this.gamePlayer(), Brew.colors.violet));
      return true;
    };

    AbilityCode.prototype.entangle_execute = function(caster, from_xy, center_xy) {
      var entangler, impact_lst;
      entangler = Brew.featureFactory("PROJ_ENTANGLE", {
        damage: 0
      });
      entangler.setFlag(Brew.flags.weapon_stun);
      impact_lst = center_xy.getSurrounding();
      impact_lst.push(center_xy);
      this.game.addAnimation(new Brew.ImpactAnimation(impact_lst, entangler.color, caster, entangler));
      return true;
    };

    AbilityCode.prototype.warcry_execute = function(caster, from_xy, center_xy) {
      var m, message, thing_id, _i, _len, _ref;
      if (!Brew.utils.compareThing(caster, this.gamePlayer())) {
        message = "A terrifying war cry echos across reality";
      } else {
        message = "You roar a terrifying war cry!!";
      }
      this.game.msg(message);
      this.game.addAnimation(new Brew.ShinyAnimation(this.gamePlayer(), Brew.colors.hf_orange));
      _ref = this.gamePlayer().knowledge;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        thing_id = _ref[_i];
        m = this.gameLevel().getMonsterById(thing_id);
        console.log(thing_id, m);
        if (m != null) {
          this.game.setFlagWithCounter(m, Brew.flags.is_scared, 10);
          this.game.ui.showDialogAbove(m.coordinates, Brew.Messages.getRandom("scared"));
        }
      }
      return true;
    };

    AbilityCode.prototype.defend_execute = function(caster, from_xy, center_xy) {
      var message;
      if (!Brew.utils.compareThing(caster, this.gamePlayer())) {
        message = "" + this.game.pair.username + " is defending you!";
      } else {
        message = "You take a moment to ready your defenses";
      }
      this.game.msg(message);
      this.game.addAnimation(new Brew.ShinyAnimation(this.gamePlayer(), Brew.colors.red));
      this.game.setFlagWithCounter(this.gamePlayer(), Brew.flags.defended, 10);
      return true;
    };

    AbilityCode.prototype.generic_canUseAt = function(ability, map_xy) {
      var ability_def, actual_xy, data, dist2d, has_stamina, i, last_xy, line, m, t, target_mob, xy, _i, _len;
      ability_def = Brew.ability[ability];
      dist2d = Brew.utils.dist2d(this.gamePlayer().coordinates, map_xy);
      if (dist2d > ability_def.range) {
        return [false, "Out of range"];
      }
      if (ability_def.pathing) {
        line = Brew.utils.getLineBetweenPoints(this.gamePlayer().coordinates, map_xy);
        last_xy = null;
        actual_xy = null;
        for (i = _i = 0, _len = line.length; _i < _len; i = ++_i) {
          xy = line[i];
          if (i === 0) {
            last_xy = xy;
            continue;
          }
          t = this.gameLevel().getTerrainAt(xy);
          if (t.blocks_flying) {
            return [false, "Something is in the way"];
          }
          if (i === (line.length - 1)) {
            last_xy = xy;
            continue;
          }
          m = this.gameLevel().getMonsterAt(xy);
          if (m != null) {
            return [false, "SomeTHING is in the way"];
          }
          last_xy = xy;
        }
        if (actual_xy == null) {
          actual_xy = map_xy;
        }
      } else {
        actual_xy = map_xy;
      }
      target_mob = this.gameLevel().getMonsterAt(map_xy);
      if (ability_def.needs_target && (target_mob == null)) {
        return [false, "Target required"];
      }
      has_stamina = this.gamePlayer().getStat(Brew.stat.stamina).getCurrent() >= ability_def.cost;
      if (!has_stamina) {
        return [false, "not enough stamina"];
      }
      data = {
        "xy": actual_xy
      };
      if (ability_def.needs_target) {
        data.target = target_mob;
      }
      return [true, data];
    };

    return AbilityCode;

  })();

}).call(this);

//# sourceMappingURL=brew_abilities.map
