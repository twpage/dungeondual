// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  window.Brew.Game = (function() {
    function Game(display_info, game_id, user_id, gamekey) {
      this.game_id = game_id;
      this.user_id = user_id;
      this.gamekey = gamekey;
      this.levels = {};
      this.pathmaps = {};
      this.my_level = null;
      this.my_player = null;
      this.intel = null;
      this.turn = 0;
      this.levelgen = null;
      this.animations = [];
      this.scheduler = new ROT.Scheduler.Speed();
      this.ui = new Brew.UserInterface(this, display_info);
      this.abilities = null;
      this.levelseeds = [];
      this.socket = new Brew.Socket(this);
      this.is_paired = false;
      this.pair = {};
      this.lastKeypress = 0;
      this.idle = 0;
      this.incoming_ability = {};
      this.incoming_monster = {};
      this.incoming_item = {};
      this.item_catalog = {};
      this.debugDropdownMenu();
    }

    Game.prototype.keypress = function(e) {
      this.ui.keypress(e);
      return this.lastKeypress = new Date();
    };

    Game.prototype.start = function(player_name, hero_type) {
      this.my_player = this.createPlayer(hero_type);
      this.my_player.name = player_name;
      this.intel = new Brew.Intel(this);
      this.abil = new Brew.AbilityCode(this);
      return $.ajax({
        url: "/ajax/levelseeds/" + this.gamekey,
        success: (function(_this) {
          return function(json_response) {
            return _this.finishStart(json_response);
          };
        })(this),
        dataType: "json"
      });
    };

    Game.prototype.finishStart = function(json_response) {
      var id;
      this.levelseeds = json_response["data"];
      this.randomizeItemCatalog(this.levelseeds[0]);
      this.levelgen = new Brew.LevelGenerator(this);
      id = this.createLevel(0, this.levelseeds[0]);
      this.setCurrentLevel(id);
      return setInterval((function(_this) {
        return function() {
          return _this.interval();
        };
      })(this), 5000);
    };

    Game.prototype.interval = function() {
      var now;
      if (!this.is_paired) {
        this.socket.requestDisplayUpdate();
      }
      now = new Date();
      this.idle = now - this.lastKeypress;
      if (this.lastKeypress === 0) {
        this.socket.sending = true;
        this.socket.sendDisplayUpdate();
        return this.socket.sending = false;
      } else if (this.idle > 5000) {

      } else {
        return this.socket.sendDisplayUpdate();
      }
    };

    Game.prototype.randomizeItemCatalog = function(seed) {
      var blah, flask_type, i, random_name, _ref, _results;
      ROT.RNG.setSeed(seed);
      Brew.flaskNames = Brew.flaskNames.randomize();
      i = 0;
      _ref = Brew.flaskTypes;
      _results = [];
      for (blah in _ref) {
        if (!__hasProp.call(_ref, blah)) continue;
        flask_type = _ref[blah];
        random_name = Brew.flaskNames[i];
        Brew.flaskType[flask_type].unidentified_name = "" + random_name + " Flask";
        Brew.flaskType[flask_type].is_identified = false;
        _results.push(i += 1);
      }
      return _results;
    };

    Game.prototype.isIdentified = function(item) {
      if (item.group === Brew.groups.FLASK) {
        return Brew.flaskType[item.flaskType].is_identified;
      } else {
        return true;
      }
    };

    Game.prototype.getItemDescription = function(item) {
      var desc, _ref;
      if (item.group === Brew.groups.FLASK) {
        if (Brew.flaskType[item.flaskType].is_identified) {
          desc = Brew.flaskType[item.flaskType].description;
        } else {
          desc = "Its contents are a mystery";
        }
      } else {
        desc = (_ref = item.description) != null ? _ref : "Seems normal enough";
      }
      return desc;
    };

    Game.prototype.getItemNameFromCatalog = function(item) {
      var name;
      if (item.group === Brew.groups.FLASK) {
        if (Brew.flaskType[item.flaskType].is_identified) {
          name = Brew.flaskType[item.flaskType].real_name;
        } else {
          name = Brew.flaskType[item.flaskType].unidentified_name;
        }
      } else {
        name = item.name;
      }
      if (item.owner != null) {
        return "" + item.owner + "'s " + name;
      } else {
        return name;
      }
    };

    Game.prototype.createPlayer = function(hero_type) {
      var ability, player, _i, _len, _ref;
      console.log(hero_type);
      player = Brew.monsterFactory("PLAYER");
      player.inventory.addItem(Brew.itemFactory("TIME_ORB"));
      player.hero_type = hero_type;
      player.createStat(Brew.stat.stamina, Brew.hero_type[hero_type].stamina);
      player.createStat(Brew.stat.health, Brew.hero_type[hero_type].hp);
      _ref = Brew.hero_type[hero_type].start_abilities;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ability = _ref[_i];
        player.addAbility(ability);
      }
      return player;
    };

    Game.prototype.refreshScheduler = function() {
      var agent, mob, _i, _j, _len, _len1, _ref, _ref1;
      this.scheduler.clear();
      _ref = this.my_level.getMonsters();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mob = _ref[_i];
        this.scheduler.add(mob, true);
      }
      _ref1 = this.my_level.getAgents();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        agent = _ref1[_j];
        this.scheduler.add(agent, true);
      }
      return this.endPlayerTurn();
    };

    Game.prototype.updatePathMapsFor = function(monster, calc_from) {
      if (calc_from == null) {
        calc_from = false;
      }
      monster.pathmaps[Brew.paths.to_player] = Brew.PathMap.createMapToPlayer(this.my_level, this.my_player.coordinates, monster, 10);
      if (calc_from) {
        return monster.pathmaps[Brew.paths.from_player] = Brew.PathMap.createMapFromPlayer(this.my_level, this.my_player.coordinates, monster, monster.pathmaps[Brew.paths.to_player], 10);
      }
    };

    Game.prototype.setCurrentLevel = function(level_id, arrive_xy) {
      this.my_level = this.levels[level_id];
      this.my_level.setMonsterAt((arrive_xy != null ? arrive_xy : this.my_level.start_xy), this.my_player);
      this.my_level.updateLightMap();
      this.refreshScheduler();
      this.updateAllFov();
      this.ui.centerViewOnPlayer();
      this.ui.drawDisplayAll();
      return this.ui.drawHudAll();
    };

    Game.prototype.updateAllFov = function() {
      var monster, _i, _len, _ref;
      _ref = this.my_level.getMonsters();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        monster = _ref[_i];
        if (monster.objtype === "monster") {
          monster.updateFov(this.my_level);
        }
      }
      return true;
    };

    Game.prototype.changeLevels = function(portal) {
      var next_id, next_level, seed;
      if (portal.to_level_id === -1) {
        seed = this.levelseeds[this.my_level.depth + 1];
        next_id = this.createLevel(this.my_level.depth + 1, seed);
        next_level = this.levels[next_id];
        next_level.setLinkedPortalAt(next_level.start_xy, this.my_level.id, this.my_level.exit_xy);
        this.my_level.setLinkedPortalAt(this.my_level.exit_xy, next_id, next_level.start_xy);
        return this.setCurrentLevel(next_id, next_level.start_xy);
      } else {
        return this.setCurrentLevel(portal.to_level_id, portal.level_xy);
      }
    };

    Game.prototype.createLevel = function(depth, level_seed) {
      var level;
      level = this.levelgen.create(depth, Brew.config.level_tiles_width, Brew.config.level_tiles_height, {}, level_seed);
      this.levels[level.id] = level;
      $.ajax({
        url: "/ajax/progress/" + this.game_id + "/" + this.user_id + "/" + depth + "/",
        success: (function(_this) {
          return function(json_response) {};
        })(this),
        dataType: "json"
      });
      return level.id;
    };

    Game.prototype.canApply = function(item, applier) {
      if (applier == null) {
        applier = this.my_player;
      }
      return applier.inventory.hasItem(item) && Brew.group[item.group].canApply;
    };

    Game.prototype.canEquip = function(item, equipee) {
      if (equipee == null) {
        equipee = this.my_player;
      }
      return equipee.inventory.hasItem(item) && Brew.group[item.group].canEquip;
    };

    Game.prototype.canRemove = function(item, equipee) {
      if (equipee == null) {
        equipee = this.my_player;
      }
      return equipee.inventory.hasItem(item) && Brew.group[item.group].equip_slot && (item.equip != null);
    };

    Game.prototype.canDrop = function(item, dropper) {
      if (dropper == null) {
        dropper = this.my_player;
      }
      return dropper.inventory.hasItem(item) && item.group !== Brew.groups.ORB;
    };

    Game.prototype.canMove = function(monster, terrain) {
      if (terrain.blocks_walking) {
        if ((terrain.can_open != null) && terrain.can_open) {
          return true;
        } else {
          if (monster.hasFlag(Brew.flags.is_flying) && !terrain.blocks_flying) {
            return true;
          } else {
            return false;
          }
        }
      } else {
        return true;
      }
    };

    Game.prototype.msg = function(text) {
      console.log(text);
      this.ui.addMessage(text, this.turn);
      return this.ui.drawMessagesPanel();
    };

    Game.prototype.msgFrom = function(monster, text) {
      if (this.my_player.hasKnowledgeOf(monster)) {
        return this.msg(text);
      }
    };

    Game.prototype.doPlayerMoveTowards = function(destination_xy) {
      var knows_path, next_xy, offset_xy, path;
      knows_path = this.my_player.canView(destination_xy) || (this.my_player.getMemoryAt(this.my_level.id, destination_xy) != null);
      offset_xy = null;
      if (knows_path) {
        path = this.findPath_AStar(this.my_player, this.my_player.coordinates, destination_xy);
        if (path != null) {
          next_xy = path[1];
          offset_xy = next_xy.subtract(this.my_player.coordinates).asUnit();
        }
      }
      if (offset_xy == null) {
        offset_xy = destination_xy.subtract(this.my_player.coordinates).asUnit();
      }
      return this.movePlayer(offset_xy);
    };

    Game.prototype.movePlayer = function(offset_xy) {
      var agent, monster, new_xy, t, takesTurn;
      new_xy = this.my_player.coordinates.add(offset_xy);
      monster = this.my_level.getMonsterAt(new_xy);
      agent = this.my_level.getAgentAt(new_xy);
      t = this.my_level.getTerrainAt(new_xy);
      if (!this.my_level.checkValid(new_xy)) {
        return this.msg("You can't go that way");
      } else if (monster != null) {
        return this.doPlayerBumpMonster(monster);
      } else if (agent != null) {
        takesTurn = Brew.Agent.interactWithAgent(this, this.my_level, this.my_player, agent);
        if (takesTurn) {
          return this.endPlayerTurn();
        }
      } else if (t.blocks_walking && !(this.my_player.hasFlag(Brew.flags.is_flying) && !t.blocks_flying)) {
        if (t.can_apply != null) {
          return this.doPlayerApplyTerrain(t, true);
        } else {
          return this.msg("You can't move there");
        }
      } else {
        this.ui.updateTerrainFooter(this.my_player.coordinates, new_xy);
        this.moveThing(this.my_player, new_xy);
        return this.endPlayerTurn();
      }
    };

    Game.prototype.getApplicableTerrain = function(thing) {
      var apply_list, neighbors, t, xy, _i, _len;
      neighbors = thing.coordinates.getSurrounding();
      apply_list = [];
      for (_i = 0, _len = neighbors.length; _i < _len; _i++) {
        xy = neighbors[_i];
        t = this.my_level.getTerrainAt(xy);
        if ((t != null) && (t != null ? t.can_apply : void 0) === true) {
          apply_list.push([xy.subtract(thing.coordinates), t]);
        }
      }
      return apply_list;
    };

    Game.prototype.applyTerrain = function(terrain, applier, bump) {
      if (Brew.utils.isTerrain(terrain, "DOOR_CLOSED")) {
        this.my_level.setTerrainAt(terrain.coordinates, Brew.terrainFactory("DOOR_OPEN"));
        return true;
      } else if (Brew.utils.isTerrain(terrain, "DOOR_OPEN")) {
        this.my_level.setTerrainAt(terrain.coordinates, Brew.terrainFactory("DOOR_CLOSED"));
        return true;
      }
      this.msg("You aren't sure how to apply that " + terrain.name);
      return false;
    };

    Game.prototype.moveThing = function(thing, new_xy, swap_override) {
      var existing_monster, old_xy, t;
      if (swap_override == null) {
        swap_override = false;
      }
      t = this.my_level.getTerrainAt(new_xy);
      if (Brew.utils.isTerrain(t, "DOOR_CLOSED")) {
        this.applyTerrain(t, thing, true);
        return false;
      }
      existing_monster = this.my_level.getMonsterAt(new_xy);
      if ((existing_monster != null) && swap_override) {
        old_xy = thing.coordinates;
        this.my_level.setMonsterAt(new_xy, thing);
        this.my_level.setMonsterAt(old_xy, existing_monster);
      } else if ((existing_monster != null) && !swap_override) {
        console.error("attempting to move monster to location with existing monster");
        return false;
      } else {
        old_xy = thing.coordinates;
        this.my_level.removeMonsterAt(old_xy);
        this.my_level.setMonsterAt(new_xy, thing);
      }
      return true;
    };

    Game.prototype.doPlayerAction = function() {
      var item, portal;
      item = this.my_level.getItemAt(this.my_player.coordinates);
      portal = this.my_level.getPortalAt(this.my_player.coordinates);
      if (item != null) {
        if (item.group === Brew.groups.INFO) {
          this.ui.popup.context = "info";
          this.ui.popup.item = item;
          return this.ui.showInfoScreen();
        } else if (item.group === Brew.groups.CORPSE) {
          return this.msg("You don't want to pick that up.");
        } else {
          return this.doPlayerPickup(item);
        }
      } else if (portal != null) {
        return this.changeLevels(portal);
      } else {
        return this.doPlayerRest();
      }
    };

    Game.prototype.doPlayerRest = function() {
      var last_attacked, recharge, _ref;
      if (this.is_paired && this.pair.sync.status) {
        recharge = 2;
      } else {
        recharge = 1;
      }
      last_attacked = (_ref = this.my_player.last_attacked) != null ? _ref : 0;
      if ((this.turn - last_attacked) > Brew.config.wait_to_heal && (!this.my_player.hasFlag(Brew.flags.poisoned))) {
        this.my_player.getStat(Brew.stat.stamina).addTo(recharge);
        this.ui.drawHudAll();
      }
      return this.endPlayerTurn();
    };

    Game.prototype.getActualImpactFromTarget = function(start_xy, target_xy, projectile) {
      var i, last_xy, line, m, t, xy, _i, _len;
      line = Brew.utils.getLineBetweenPoints(start_xy, target_xy);
      last_xy = null;
      for (i = _i = 0, _len = line.length; _i < _len; i = ++_i) {
        xy = line[i];
        if (i === 0) {
          last_xy = xy;
          continue;
        }
        t = this.my_level.getTerrainAt(xy);
        if (t.blocks_flying) {
          return last_xy;
        }
        m = this.my_level.getMonsterAt(xy);
        if (m != null) {
          return xy;
        }
        last_xy = xy;
      }
      return last_xy;
    };

    Game.prototype.doPlayerPickup = function(item) {
      var inv_key;
      inv_key = this.my_player.inventory.addItem(item);
      if (!inv_key) {
        return this.msg("My inventory is full!");
      } else {
        this.my_level.removeItemAt(this.my_player.coordinates);
        this.msg("Picked up " + this.getItemNameFromCatalog(item) + " (" + item.inv_key_lower + ")");
        return this.endPlayerTurn();
      }
    };

    Game.prototype.doPlayerDrop = function(item) {
      var item_at;
      if (!item) {
        return false;
      }
      item_at = this.my_level.getItemAt(this.my_player.coordinates);
      if (item_at != null) {
        this.msg("There's something on the ground here already.");
        return false;
      }
      if (item.group === Brew.groups.TIMEORB) {
        this.msg("You dare not drop the Time Orb.");
        return false;
      }
      if (item.equip != null) {
        this.doPlayerRemove(item);
      }
      this.my_player.inventory.removeItemByKey(item.inv_key);
      this.my_level.setItemAt(this.my_player.coordinates, item);
      this.msg("I'll just leave this here: " + this.getItemNameFromCatalog(item));
      return true;
    };

    Game.prototype.doPlayerGive = function(item) {
      if (!item) {
        return false;
      }
      if (item.group === Brew.groups.TIMEORB) {
        this.msg("The Time Orb will not travel realms.");
        return false;
      }
      if (!this.is_paired) {
        this.msg("You sense no one to give this to.");
        return false;
      }
      if (this.is_paired && !this.pair.sync.status) {
        this.msg("You are too far from your ally.");
        return false;
      }
      if (item.equip != null) {
        this.doPlayerRemove(item);
      }
      this.my_player.inventory.removeItemByKey(item.inv_key);
      this.socket.sendItem(item);
      this.msg("You send " + (this.getItemNameFromCatalog(item)) + " to " + this.pair.username);
      return true;
    };

    Game.prototype.doPlayerEquip = function(item) {
      var existing, slot;
      if (!item) {
        return false;
      }
      slot = Brew.group[item.group].equip_slot;
      if (slot == null) {
        this.msg("You're not sure where to put that...");
        return false;
      }
      existing = this.my_player.inventory.getEquipped(slot);
      if (existing != null) {
        this.doPlayerRemove(existing);
      }
      this.my_player.inventory.equipItem(item, slot);
      this.msg("You are " + Brew.group[item.group].equip_verb + " " + this.getItemNameFromCatalog(item) + " (" + item.inv_key_lower + ")");
      this.ui.drawHudAll();
      return true;
    };

    Game.prototype.doPlayerRemove = function(item) {
      if (!item) {
        return false;
      }
      if (!this.canRemove(item)) {
        if (!this.canEquip(item)) {
          this.msg("I'm not sure how to remove that.");
        } else {
          this.msg("That's not equipped.");
        }
        return false;
      }
      this.my_player.inventory.unequipItem(item);
      this.msg("You've stopped " + Brew.group[item.group].equip_verb + " " + this.getItemNameFromCatalog(item) + " (" + item.inv_key_lower + ")");
      this.ui.drawHudAll();
      return true;
    };

    Game.prototype.doPlayerApply = function(item, inv_key) {
      if (!item) {
        return false;
      }
      if (!this.canApply(item)) {
        this.msg("I'm can't apply that.");
        return false;
      }
      this.applyItem(this.my_player, item);
      return true;
    };

    Game.prototype.doPlayerApplyTerrain = function(terrain, bump) {
      var success;
      success = this.applyTerrain(terrain, this.my_player, bump);
      if (success) {
        return this.endPlayerTurn();
      }
    };

    Game.prototype.applyItem = function(applier, item) {
      if (item.group === Brew.groups.TIMEORB) {
        if (!this.is_paired) {
          return this.msg("The Time Orb looks dull and lifeless");
        } else if (this.is_paired && !this.pair.sync.status) {
          return this.msg("The Time Orb glows faintly");
        } else {
          return this.msg("The Time Orb pulses with light");
        }
      } else if (item.group === Brew.groups.FLASK) {
        this.msg("You open " + (this.getItemNameFromCatalog(item)) + "...");
        this.useFlask(this.my_player, item);
        return this.my_player.inventory.removeItemByKey(item.inv_key);
      } else {
        throw "error - non-appliable item";
      }
    };

    Game.prototype.useFlask = function(user, flask) {
      if (flask.flaskType === Brew.flaskTypes.fire) {
        this.setFlagWithCounter(user, Brew.flags.on_fire, 5);
        this.msg("You are on fire!");
        this.ui.drawMapAt(user.coordinates);
      } else if (flask.flaskType === Brew.flaskTypes.health) {
        this.msg("Your health improves!");
        user.getStat(Brew.stat.health).addToMax(1);
        user.getStat(Brew.stat.health).reset();
        this.ui.drawHudAll();
      } else if (flask.flaskType === Brew.flaskTypes.weakness) {
        this.msg("A wave of weakness overwhelms you");
        user.getStat(Brew.stat.stamina).setTo(0);
        this.ui.drawHudAll();
      } else if (flask.flaskType === Brew.flaskTypes.might) {
        this.setFlagWithCounter(user, Brew.flags.is_mighty, 20);
        this.msg("Supernatural strength flows through you");
        this.ui.drawMapAt(user.coordinates);
      } else if (flask.flaskType === Brew.flaskTypes.invisible) {
        this.setFlagWithCounter(user, Brew.flags.invisible, 10);
        this.msg("You can see right through yourself!");
        this.ui.drawMapAt(user.coordinates);
      } else if (flask.flaskType === Brew.flaskTypes.vigor) {
        this.msg("This makes you feel amazing!");
        user.getStat(Brew.stat.stamina).addToMax(1);
        user.getStat(Brew.stat.stamina).reset();
        this.ui.drawHudAll();
      } else {
        console.error("unexpected flask item", flask);
      }
      Brew.flaskType[flask.flaskType].is_identified = true;
      return true;
    };

    Game.prototype.doPlayerBumpMonster = function(bumpee) {
      if (bumpee.objtype === "monster") {
        this.meleeAttack(this.my_player, bumpee);
      } else if (bumpee.objtype === "agent") {
        Brew.Actor.handleBump(this, this.my_player, bumpee);
      } else {
        throw "a horrible error happened when bumping a monster";
      }
      return this.endPlayerTurn();
    };

    Game.prototype.canAttack = function(attacker, target_mob) {
      var attack_range, xy;
      attack_range = attacker.getAttackRange();
      if (attack_range === 0) {
        return false;
      } else if (attack_range === 1) {
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = attacker.coordinates.getAdjacent();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            xy = _ref[_i];
            if (xy.compare(target_mob.coordinates)) {
              _results.push(xy);
            }
          }
          return _results;
        })()).length > 0;
      } else if (attack_range === 1.5) {
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = attacker.coordinates.getSurrounding();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            xy = _ref[_i];
            if (xy.compare(target_mob.coordinates)) {
              _results.push(xy);
            }
          }
          return _results;
        })()).length > 0;
      } else {
        return this.checkRangedAttack(attacker, target_mob)[0];
      }
    };

    Game.prototype.getPotentialTargets = function(shooter, target_def) {
      var enemies_in_view, err_msg, is_ok, m, potential_targets, target_player, traverse_lst, _i, _len, _ref;
      if (target_def.range == null) {
        console.error("need at least range in target definition");
      }
      target_player = typeof false !== "undefined" && false !== null ? false : target_def.target_player;
      if (target_player) {
        enemies_in_view = (function() {
          var _i, _len, _ref, _results;
          _ref = this.my_level.getMonsters();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (shooter.hasKnowledgeOf(m) && Brew.utils.compareThing(m, this.my_player)) {
              _results.push(m);
            }
          }
          return _results;
        }).call(this);
      } else {
        enemies_in_view = (function() {
          var _i, _len, _ref, _results;
          _ref = this.my_level.getMonsters();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (shooter.hasKnowledgeOf(m) && !Brew.utils.compareThing(m, this.my_player)) {
              _results.push(m);
            }
          }
          return _results;
        }).call(this);
      }
      potential_targets = [];
      for (_i = 0, _len = enemies_in_view.length; _i < _len; _i++) {
        m = enemies_in_view[_i];
        _ref = this.checkGenericRangedAttack(shooter.coordinates, m.coordinates, {
          range: target_def.range,
          blockedByTerrain: true,
          blockedByOtherTargets: true
        }), is_ok = _ref[0], err_msg = _ref[1], traverse_lst = _ref[2];
        if (is_ok) {
          potential_targets.push(m);
        }
      }
      return potential_targets;
    };

    Game.prototype.checkGenericRangedAttack = function(start_xy, target_xy, target_def) {
      var dist, full_traverse_lst, i, len, m, t, traverse_lst, xy, _i, _len;
      dist = Brew.utils.dist2d(start_xy, target_xy);
      if (dist > target_def.range) {
        return [false, Brew.errors.ATTACK_OUT_OF_RANGE, []];
      }
      full_traverse_lst = Brew.utils.getLineBetweenPoints(start_xy, target_xy);
      if (full_traverse_lst.length < 2) {
        throw "Traversal path should never be less than 2";
      } else {
        len = full_traverse_lst.length;
        traverse_lst = full_traverse_lst.slice(1, +(len - 1) + 1 || 9e9);
      }
      for (i = _i = 0, _len = traverse_lst.length; _i < _len; i = ++_i) {
        xy = traverse_lst[i];
        if (i === (traverse_lst.length - 1)) {
          continue;
        }
        t = this.my_level.getTerrainAt(xy);
        if (t.blocks_walking && target_def.blockedByTerrain) {
          return [false, Brew.errors.ATTACK_BLOCKED_TERRAIN, []];
        }
        m = this.my_level.getMonsterAt(xy);
        if ((m != null) && target_def.blockedByOtherTargets) {
          return [false, Brew.errors.ATTACK_BLOCKED_MONSTER + m.name, []];
        }
      }
      return [true, "OK", traverse_lst];
    };

    Game.prototype.checkRangedAttack = function(attacker, target) {
      var err_msg, is_ok, traverse_lst, _ref;
      if (!attacker.hasKnowledgeOf(target)) {
        return [false, Brew.errors.ATTACK_NOT_KNOWN, []];
      }
      if (!attacker.canView(target.coordinates)) {
        return [false, Brew.errors.ATTACK_NOT_VISIBLE, []];
      }
      _ref = this.checkGenericRangedAttack(attacker.coordinates, target.coordinates, {
        range: attacker.getAttackRange(),
        blockedByTerrain: true,
        blockedByOtherTargets: true
      }), is_ok = _ref[0], err_msg = _ref[1], traverse_lst = _ref[2];
      console.log(attacker, err_msg);
      return [is_ok, err_msg, traverse_lst];
    };

    Game.prototype.meleeAttack = function(attacker, defender) {
      return this.attack(attacker, defender, true);
    };

    Game.prototype.doMonsterAttack = function(monster, defender) {
      var is_melee, laserbeam, neighbors, start_xy, target_xy, traverse_lst;
      neighbors = defender.coordinates.getSurrounding();
      is_melee = neighbors.some(function(xy) {
        return monster.coordinates.compare(xy);
      });
      if (!is_melee) {
        start_xy = monster.coordinates;
        target_xy = defender.coordinates;
        traverse_lst = Brew.utils.getLineBetweenPoints(start_xy, target_xy);
        traverse_lst = traverse_lst.slice(1, +(traverse_lst.length - 1) + 1 || 9e9);
        laserbeam = Brew.featureFactory("PROJ_MONSTERBOLT", {
          code: Brew.utils.getLaserProjectileCode(start_xy, target_xy),
          damage: monster.damage
        });
        return this.addAnimation(new Brew.ProjectileAnimation(monster, laserbeam, traverse_lst));
      } else {
        return this.attack(monster, defender, is_melee);
      }
    };

    Game.prototype.attack = function(attacker, defender, is_melee, options) {
      var attacker_is_player, block, combat_msg, damage, defender_armor, defender_is_player, equipped_wpn, flash_color, intensity, is_dead, key, overkill, splat, t, weapon, xy, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      defender.last_attacked = this.turn;
      attacker_is_player = attacker.group === "player";
      if (defender == null) {
        debugger;
      }
      defender_is_player = defender.group === "player";
      combat_msg = "";
      if (attacker_is_player) {
        combat_msg += "You ";
        combat_msg += is_melee ? "punch " : "fire at ";
        combat_msg += "the " + defender.name;
      } else {
        combat_msg += "The " + attacker.name + " ";
        combat_msg += is_melee ? "attacks " : "shoots at ";
        combat_msg += defender_is_player ? "you" : "the " + defender.name;
      }
      if (options.remote == null) {
        this.msg(combat_msg);
      }
      weapon = null;
      equipped_wpn = (_ref = attacker.inventory) != null ? _ref.getEquipped(Brew.equip_slot.melee) : void 0;
      if (options.remote != null) {
        weapon = options.remote;
      } else if (equipped_wpn != null) {
        weapon = equipped_wpn;
      }
      if (weapon == null) {
        damage = attacker.getAttackDamage(is_melee);
      } else {
        damage = weapon.damage;
      }
      if (attacker.hasFlag(Brew.flags.is_mighty)) {
        damage = Math.floor(damage * Brew.config.mighty_damage_mult);
      }
      if (attacker_is_player) {
        damage += Brew.config.damage_fix;
      }
      defender_armor = (_ref1 = defender.inventory) != null ? _ref1.getEquipped(Brew.equip_slot.body) : void 0;
      if (defender_armor != null) {
        console.log("armor block");
        block = (_ref2 = defender_armor.block) != null ? _ref2 : 1;
        damage = Math.max(0, damage - block);
      }
      if (defender.hasFlag(Brew.flags.defended)) {
        damage = Math.max(1, damage - Brew.config.defended_block);
      }
      console.log("damage was ", damage);
      if (defender_is_player) {
        damage = defender.getStat(Brew.stat.stamina).deductOverflow(damage);
      }
      overkill = defender.getStat(Brew.stat.health).deductOverflow(damage);
      if (damage > 0 && defender.hasFlag(Brew.flags.stunned)) {
        defender.removeFlagCounter(Brew.flags.stunned);
        defender.removeFlag(Brew.flags.stunned);
      }
      if (!(options != null ? options.noEffects : void 0)) {
        this.attackEffects(attacker, defender, weapon, is_melee, damage);
      }
      is_dead = defender.getStat(Brew.stat.health).isZero();
      this.ui.drawHudAll();
      splat = Brew.utils.createSplatter(defender.coordinates, 3);
      for (key in splat) {
        if (!__hasProp.call(splat, key)) continue;
        intensity = splat[key];
        xy = keyToCoord(key);
        t = this.my_level.getTerrainAt(xy);
        if (t.show_gore) {
          this.my_level.setFeatureAt(xy, Brew.featureFactory("BLOOD", {
            intensity: intensity
          }));
        }
      }
      if (is_melee && !is_dead) {
        flash_color = Brew.colors.red;
        return this.addAnimation(new Brew.FlashAnimation(clone(defender.coordinates), flash_color));
      } else {
        return this.finishAttack(attacker, defender, is_melee, overkill);
      }
    };

    Game.prototype.finishAttack = function(attacker, defender, is_melee, overkill) {
      var defender_is_player, is_dead;
      is_dead = defender.getStat(Brew.stat.health).isZero();
      defender_is_player = defender.group === "player";
      if (is_dead && defender_is_player) {
        this.killPlayer(attacker, defender, is_melee, overkill);
      } else if (is_dead) {
        this.killMonster(attacker, defender, is_melee, overkill);
      }
      return true;
    };

    Game.prototype.remoteImpact = function(attacker, location_xy, weapon) {
      var m;
      m = this.my_level.getMonsterAt(location_xy);
      if (m != null) {
        return this.attack(attacker, m, false, {
          remote: weapon
        });
      }
    };

    Game.prototype.killPlayer = function(killer, victim_player, is_melee, overkill_damage) {
      console.log("you died!");
      return $.ajax({
        url: "/ajax/died/" + this.game_id + "/" + this.user_id + "/" + (this.my_level.depth + 1) + "/" + killer.name + "/",
        success: (function(_this) {
          return function(json_response) {
            return _this.finishKillPlayer(json_response);
          };
        })(this),
        dataType: "json"
      });
    };

    Game.prototype.finishKillPlayer = function(json_response) {
      return this.ui.showDied();
    };

    Game.prototype.killMonster = function(attacker, victim, is_melee, overkill_damage) {
      var dead_xy;
      dead_xy = clone(victim.coordinates);
      this.msg("You kill the " + victim.name);
      victim.is_dead = true;
      if (victim.light_source != null) {
        this.my_level.updateLightMap();
      }
      this.my_level.removeMonsterAt(victim.coordinates);
      this.scheduler.remove(victim);
      this.ui.drawMapAt(dead_xy);
      if (victim.def_id === "TIME_MASTER") {
        return this.doVictory();
      }
    };

    Game.prototype.doVictory = function() {
      console.log("you won!");
      return $.ajax({
        url: "/ajax/victory/" + this.game_id + "/",
        success: (function(_this) {
          return function(json_response) {
            return _this.finishVictory(json_response);
          };
        })(this),
        dataType: "json"
      });
    };

    Game.prototype.finishVictory = function(json_response) {
      return this.ui.showVictory();
    };

    Game.prototype.attackEffects = function(attacker, defender, attack_wpn, is_melee, damage) {
      var defender_is_player, effect_xy, monster_at, offset_xy, _i, _len, _ref, _results;
      defender_is_player = Brew.utils.compareThing(defender, this.my_player);
      if ((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_pierce)) {
        offset_xy = defender.coordinates.subtract(attacker.coordinates).multiply(2);
        effect_xy = attacker.coordinates.add(offset_xy);
        monster_at = this.my_level.getMonsterAt(effect_xy);
        if (monster_at != null) {
          return this.attack(attacker, monster_at, is_melee);
        }
      } else if ((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_smash)) {
        _ref = attacker.coordinates.getSurrounding();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          effect_xy = _ref[_i];
          if (effect_xy.compare(defender.coordinates)) {
            continue;
          }
          monster_at = this.my_level.getMonsterAt(effect_xy);
          if (monster_at != null) {
            _results.push(this.attack(attacker, monster_at, is_melee, {
              noEffects: true
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if ((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_stun)) {
        if (!defender.hasFlag(Brew.flags.stunned)) {
          this.msg("" + defender.name + " is stunned!");
          return this.setFlagWithCounter(defender, Brew.flags.stunned, 5);
        }
      } else if ((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_stun_chance)) {
        if (ROT.RNG.getUniform() < Brew.config.stun_chance) {
          if (!defender.hasFlag(Brew.flags.stunned)) {
            this.msg("" + defender.name + " is stunned!");
            return this.setFlagWithCounter(defender, Brew.flags.stunned, 5);
          }
        }
      } else if (((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_burning)) || attacker.hasFlag(Brew.flags.weapon_burning)) {
        this.setFlagWithCounter(defender, Brew.flags.on_fire, 5);
        if (defender_is_player) {
          return this.msg("You are on fire!");
        } else {
          return this.ui.showDialogAbove(defender.coordinates, Brew.Messages.getRandom("burning"));
        }
      } else if (((attack_wpn != null) && attack_wpn.hasFlag(Brew.flags.weapon_poison)) || attacker.hasFlag(Brew.flags.weapon_poison)) {
        this.setFlagWithCounter(defender, Brew.flags.poisoned, 5);
        if (defender_is_player) {
          return this.msg("You've been poisoned!");
        } else {
          return this.ui.showDialogAbove(defender.coordinates, "Ack!", Brew.colors.green);
        }
      }
    };

    Game.prototype.endPlayerTurn = function() {
      this.turn += 1;
      this.pathmaps[Brew.paths.to_player] = Brew.PathMap.createGenericMapToPlayer(this.my_level, this.my_player.coordinates, 10);
      this.checkForIncoming();
      return this.nextTurn();
    };

    Game.prototype.animationTurn = function(animation) {
      animation.runTurn(this, this.ui, this.my_level);
      if (!animation.active) {
        this.removeAnimation(animation);
      }
      this.finishEndPlayerTurn({
        update_all: animation.over_saturate,
        over_saturate: animation.over_saturate
      });
      setTimeout((function(_this) {
        return function() {
          return _this.nextTurn();
        };
      })(this), Brew.config.animation_speed);
    };

    Game.prototype.nextTurn = function() {
      var first_animation, monster, next_actor;
      if (this.hasAnimations()) {
        first_animation = this.animations[0];
        this.animationTurn(first_animation);
        return;
      }
      next_actor = this.scheduler.next();
      if (next_actor.group === "player") {
        this.checkFlagCounters(next_actor);
        this.finishEndPlayerTurn({
          update_all: true,
          over_saturate: false
        });
        this.updatePairSync();
        return;
      }
      if (next_actor.objtype === "monster") {
        monster = next_actor;
        if (monster.is_dead != null) {
          console.error("trying to run a turn on a dead monster, should be removed from scheduler");
          debugger;
        }
        monster.updateFov(this.my_level);
        this.checkFlagCounters(next_actor);
        this.intel.doMonsterTurn(monster);
        this.finishEndPlayerTurn();
        this.nextTurn();
      }
    };

    Game.prototype.finishEndPlayerTurn = function(options) {
      var overSaturate, updateAll, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      updateAll = (_ref = options.update_all) != null ? _ref : false;
      overSaturate = (_ref1 = options.over_saturate) != null ? _ref1 : false;
      if (updateAll) {
        this.my_level.updateLightMap();
        this.updateAllFov();
        this.ui.centerViewOnPlayer();
        return this.ui.drawDisplayAll({
          over_saturate: overSaturate
        });
      }
    };

    Game.prototype.findPath_AStar = function(thing, start_xy, end_xy) {
      return this.find_AStar(thing, start_xy, end_xy, false);
    };

    Game.prototype.findMove_AStar = function(thing, start_xy, end_xy) {
      return this.find_AStar(thing, start_xy, end_xy, true);
    };

    Game.prototype.find_AStar = function(thing, start_xy, end_xy, returnNextMoveOnly) {
      var astar, next_xy, passable_fn, path, update_fn;
      passable_fn = (function(_this) {
        return function(x, y) {
          var m, t, xy;
          xy = new Coordinate(x, y);
          t = _this.my_level.getTerrainAt(xy);
          if (t != null) {
            if (!_this.canMove(thing, t)) {
              return false;
            } else {
              m = _this.my_level.getMonsterAt(xy);
              if (m != null) {
                if (thing.group === "player") {
                  return true;
                } else if (thing.id === m.id) {
                  return true;
                } else {
                  return false;
                }
              } else {
                return true;
              }
            }
          } else {
            return false;
          }
        };
      })(this);
      path = [];
      update_fn = function(x, y) {
        return path.push(new Coordinate(x, y));
      };
      astar = new ROT.Path.AStar(end_xy.x, end_xy.y, passable_fn, {
        topology: 8
      });
      astar.compute(start_xy.x, start_xy.y, update_fn);
      next_xy = path[1];
      if (returnNextMoveOnly) {
        return next_xy != null ? next_xy : null;
      } else {
        return path;
      }
    };

    Game.prototype.execMonsterTurnResult = function(monster, result) {
      if (result.action === "sleep") {

      } else if (result.action === "move") {
        return this.moveThing(monster, result.xy);
      } else if (result.action === "wait") {
        return monster.giveup = (monster != null ? monster.giveup : void 0) ? monster.giveup + 1 : 1;
      } else if (result.action === "attack") {
        return this.doMonsterAttack(monster, result.target);
      } else if (result.action === "stand") {
        if (ROT.RNG.getUniform() < 0.25) {
          return this.msgFrom(monster, monster.name + " glowers at you from afar.");
        }
      } else if (result.action === "special") {

      } else {
        throw "unexpected AI result";
      }
    };

    Game.prototype.addAnimation = function(new_animation) {
      return this.animations.push(new_animation);
    };

    Game.prototype.removeAnimation = function(my_animation) {
      var a;
      this.animations = (function() {
        var _i, _len, _ref, _results;
        _ref = this.animations;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          if (a.id !== my_animation.id) {
            _results.push(a);
          }
        }
        return _results;
      }).call(this);
      return true;
    };

    Game.prototype.hasAnimations = function() {
      return this.animations.length > 0;
    };

    Game.prototype.doPlayerPairClick = function(pair_map_xy) {
      if (this.my_player.active_ability != null) {
        if (!this.is_paired) {
          return this.msg("You cannot sense the other realm.");
        } else if (this.is_paired && !this.pair.sync.status) {
          return this.msg("You are too far from your ally.");
        } else {
          return this.abil.execute(this.my_player.active_ability, pair_map_xy, true);
        }
      }
    };

    Game.prototype.doPlayerClick = function(map_xy) {
      if (this.my_player.active_ability != null) {
        return this.abil.execute(this.my_player.active_ability, map_xy, false);
      }
    };

    Game.prototype.doPlayerSelectAbility = function(keycode) {
      var idx, selected_abil;
      idx = keycode - 49;
      if (this.my_player.abilities.length === 0) {
        return this.msg("You don't have any abilities");
      } else if (idx >= this.my_player.abilities.length) {
        return this.msg("Invalid ability number -- too high");
      } else {
        selected_abil = this.my_player.abilities[idx];
        return this.doPlayerAbility(selected_abil, keycode);
      }
    };

    Game.prototype.doPlayerAbility = function(ability, keycode) {
      if (Brew.ability[ability].range === 0) {
        return this.abil.execute(ability, this.my_player.coordinates, false);
      } else {
        return this.ui.showTargeting(ability, keycode);
      }
    };

    Game.prototype.doTargetingAt = function(ability, target_xy) {
      var can_use, data, _ref;
      _ref = this.abil.canUseAt(ability, target_xy), can_use = _ref[0], data = _ref[1];
      if (!can_use) {
        this.msg("" + data);
        return false;
      }
      this.abil.execute(ability, target_xy, false);
      return true;
    };

    Game.prototype.checkForIncoming = function() {
      var ability, from_xy, item, to_xy, traveler, xy;
      if (this.incoming_ability.ability != null) {
        ability = this.incoming_ability.ability;
        from_xy = coordFromObject(this.incoming_ability.from_xy);
        to_xy = coordFromObject(this.incoming_ability.to_xy);
        this.incoming_ability = {};
        if (ability === Brew.abilities.fireball) {
          this.abil.fireball_execute(this.pair.player, from_xy, to_xy);
        } else if (ability === Brew.abilities.entangle) {
          this.abil.entangle_execute(this.pair.player, from_xy, to_xy);
        } else if (ability === Brew.abilities.warcry) {
          this.abil.warcry_execute(this.pair.player, from_xy, to_xy);
        } else if (ability === Brew.abilities.defend) {
          this.abil.defend_execute(this.pair.player, from_xy, to_xy);
        }
        return true;
      } else if (this.incoming_monster.name != null) {
        console.log("got a monster " + this.incoming_monster);
        xy = this.my_level.getRandomWalkableLocationNear(this.my_player.coordinates, 10);
        if (xy != null) {
          traveler = Brew.monsterFactory(this.incoming_monster.def_id, {
            status: Brew.monster_status.WANDER
          });
          this.msg("" + this.pair.username + " banishes " + traveler.name + " to your realm");
          traveler.name = this.pair.username + "'s " + traveler.name;
          this.my_level.setMonsterAt(xy, traveler);
          this.scheduler.add(traveler, true);
          this.ui.drawMapAt(xy);
          this.incoming_monster = {};
        }
        return true;
      } else if (this.incoming_item.name != null) {
        console.log("got a item " + this.incoming_item);
        xy = this.my_level.getRandomWalkableLocationNear(this.my_player.coordinates, 10);
        if (xy != null) {
          item = Brew.itemFactory(this.incoming_item.def_id);
          this.msg("" + this.pair.username + " sends " + (this.getItemNameFromCatalog(item)) + " to your realm");
          item.owner = this.pair.username;
          this.my_level.setItemAt(xy, item);
          this.ui.drawMapAt(xy);
        }
        this.incoming_item = {};
        return true;
      }
      return false;
    };

    Game.prototype.updatePairSync = function() {
      var dist2d, in_sync, message, my_depth, pair_level_depth, pair_turn, pair_xy, space, sync, turn_diff;
      in_sync = false;
      message = "";
      if (!this.is_paired) {
        in_sync = false;
        return message = "no connection";
      } else {
        pair_xy = this.pair.player.coordinates;
        pair_level_depth = this.pair.level_depth;
        pair_turn = this.pair.turn;
        my_depth = this.my_level.depth;
        if (my_depth !== pair_level_depth) {
          in_sync = false;
          if (my_depth < pair_level_depth) {
            message = "Changed Levels";
          } else {
            message = "Changed Levels";
          }
        } else {
          dist2d = Brew.utils.dist2d(this.my_player.coordinates, pair_xy);
          turn_diff = this.turn - pair_turn;
          sync = Math.sqrt(Brew.config.sync.space * Math.pow(dist2d, 2) + Brew.config.sync.time * Math.pow(turn_diff, 2));
          if (sync <= Brew.config.sync.limit) {
            in_sync = true;
            message = "OK";
          } else {
            in_sync = false;
            space = Brew.config.sync.space * dist2d;
            if (Math.abs(turn_diff) < (Brew.config.sync.limit * Brew.config.sync.time)) {
              message = "Get closer";
            } else if (turn_diff < 0) {
              message = "Hurry";
            } else {
              message = "Wait";
            }
          }
        }
        this.pair.sync = {
          "status": in_sync,
          "message": message
        };
        this.ui.drawHudSync();
        return in_sync;
      }
    };

    Game.prototype.updatePairGhost = function(pair_xy) {
      var current_xy;
      if (this.pair.player == null) {
        this.pair.player = Brew.featureFactory("PLAYER_PAIR");
        this.pair.player.name = this.pair.username;
        this.my_level.setOverheadAt(pair_xy, this.pair.player);
      }
      current_xy = clone(this.pair.player.coordinates);
      if (!current_xy.compare(pair_xy)) {
        console.log("redrawing player ghost");
        this.my_level.removeOverheadAt(current_xy);
        this.my_level.setOverheadAt(pair_xy, this.pair.player);
        this.ui.drawMapAt(current_xy);
        return this.ui.drawMapAt(pair_xy);
      }
    };

    Game.prototype.setFlagWithCounter = function(thing, flag, effect_turns) {
      thing.setFlagCounter(flag, effect_turns, this.turn + effect_turns);
      return true;
    };

    Game.prototype.checkFlagCounters = function(thing) {
      var end_turn, flag, _i, _len, _ref;
      _ref = thing.getFlagCounters();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        flag = _ref[_i];
        end_turn = thing.getFlagCount(flag);
        if (end_turn <= this.turn) {
          thing.removeFlagCounter(flag);
          if (Brew.utils.compareThing(thing, this.my_player)) {
            this.msg("You are no longer " + flag);
            this.ui.drawHudAll();
          } else {
            this.msgFrom(thing, "" + thing.name + " is no longer " + flag);
          }
        } else {
          if (flag === Brew.flags.on_fire) {
            if (Brew.utils.compareThing(thing, this.my_player)) {
              this.my_player.getStat(Brew.stat.stamina).deduct(1);
              this.my_player.last_attacked = this.turn;
              this.ui.drawHudAll();
            } else {
              thing.getStat(Brew.stat.health).deduct(1);
              if (thing.getStat(Brew.stat.health).isZero()) {
                this.killMonster(this.my_player, thing, false, 0);
              }
            }
          }
        }
      }
      return true;
    };

    Game.prototype.debugClick = function(map_xy) {
      var debug_id, def_id, monster, objtype, _ref;
      debug_id = $("#id_select_debug").val();
      _ref = debug_id.split("-"), objtype = _ref[0], def_id = _ref[1];
      if (objtype === "MONSTER") {
        monster = Brew.monsterFactory(def_id, {
          status: Brew.monster_status.WANDER
        });
        this.my_level.setMonsterAt(map_xy, monster);
        this.ui.drawMapAt(map_xy);
        return this.scheduler.add(monster, true);
      }
    };

    Game.prototype.debugDropdownMenu = function() {
      var def_id, monster_def, _ref, _results;
      _ref = Brew.monster_def;
      _results = [];
      for (def_id in _ref) {
        if (!__hasProp.call(_ref, def_id)) continue;
        monster_def = _ref[def_id];
        if (def_id === "PLAYER") {
          continue;
        }
        _results.push($("#id_select_debug").append("<option value=\"MONSTER-" + def_id + "\">" + def_id + "</option>"));
      }
      return _results;
    };

    return Game;

  })();

}).call(this);

//# sourceMappingURL=brew_game.map
