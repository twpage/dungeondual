// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Brew.UserInterface = (function() {
    function UserInterface(game, display_info) {
      this.game = game;
      this.my_display = display_info["game"];
      this.my_layer_display = display_info["layer"];
      this.my_dialog_display = display_info["dialog"];
      this.my_popup_display = display_info["popup"];
      this.my_tile_width = this.my_display.getContainer().width / Brew.config.screen_tiles_width;
      this.my_tile_height = this.my_display.getContainer().height / Brew.config.screen_tiles_height;
      this.my_view = new Coordinate(0, 0);
      this.input_handler = null;
      this.popup = {};
      this.displayat = {};
      this.highlights = {};
      this.debug = {
        fov: {},
        pathmaps: {}
      };
      setTimeout((function(_this) {
        return function() {
          _this.initLayerDisplay();
          return _this.initDialogDisplay();
        };
      })(this), 30);
    }

    UserInterface.prototype.gameLevel = function() {
      return this.game.my_level;
    };

    UserInterface.prototype.gamePlayer = function() {
      return this.game.my_player;
    };

    UserInterface.prototype.keypress = function(e) {
      var shift_key, ui_keycode;
      ui_keycode = e.keyCode;
      shift_key = e.shiftKey;
      if (this.game.hasAnimations()) {
        return console.log("ignoring input while animations finish their thing");
      } else {
        if (!this.input_handler) {
          return this.inputGameplay(ui_keycode, shift_key);
        } else if (this.input_handler === "inventory") {
          return this.inputInventory(ui_keycode);
        } else if (this.input_handler === "item_menu") {
          return this.inputItemMenu(ui_keycode);
        } else if (this.input_handler === "popup_to_dismiss") {
          return this.inputPopupToDismiss(ui_keycode);
        } else if (this.input_handler === "chat") {
          return this.inputChat(ui_keycode, shift_key);
        } else if (this.input_handler === "abilities") {
          return this.inputAbilities(ui_keycode, shift_key);
        } else if (this.input_handler === "died") {
          return this.inputDied(ui_keycode, shift_key);
        } else if (this.input_handler === "victory") {
          return this.inputVictory(ui_keycode, shift_key);
        }
      }
    };

    UserInterface.prototype.centerViewOnPlayer = function() {
      var half_x, half_y, view_x, view_y;
      if (this.gameLevel().width <= this.my_display.width && this.gameLevel().height <= this.my_display.height) {
        return;
      }
      half_x = this.my_display.getOptions().width / 2;
      half_y = this.my_display.getOptions().height / 2;
      view_x = Math.min(Math.max(0, this.gamePlayer().coordinates.x - half_x), this.gameLevel().width - this.my_display.getOptions().width);
      view_y = Math.min(Math.max(0, this.gamePlayer().coordinates.y - half_y), this.gameLevel().height - this.my_display.getOptions().height);
      return this.my_view = new Coordinate(view_x, view_y);
    };

    UserInterface.prototype.drawDisplayAll = function(options) {
      var col_x, row_y, screen_xy, _i, _ref, _results;
      this.clearLayerDisplay();
      _results = [];
      for (row_y = _i = 0, _ref = this.my_display.getOptions().height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row_y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (col_x = _j = 0, _ref1 = this.my_display.getOptions().width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col_x = 0 <= _ref1 ? ++_j : --_j) {
            screen_xy = new Coordinate(col_x, row_y);
            _results1.push(this.drawDisplayAt(screen_xy, null, options));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    UserInterface.prototype.drawMapAt = function(map_xy, options) {
      var screen_xy;
      screen_xy = map_xy.subtract(this.my_view);
      return this.drawDisplayAt(screen_xy, map_xy, options);
    };

    UserInterface.prototype.drawDisplayAt = function(xy, map_xy, options) {
      var c, can_view_and_lit, color_mod, draw, feature, fromMemory, h, in_view, is_lit, item, lighted, map_title, map_val, memory, mob_color, monster, over_saturate, overhead, pathmap, prelighting_draw, r, terrain, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      color_mod = (_ref = options != null ? options.color_mod : void 0) != null ? _ref : [0, 0, 0];
      over_saturate = (_ref1 = options != null ? options.over_saturate : void 0) != null ? _ref1 : false;
      if (map_xy == null) {
        map_xy = xy.add(this.my_view);
      }
      if (!this.gameLevel().checkValid(map_xy)) {
        console.log(map_xy);
        return;
      }
      if (this.debug.pathmaps.index != null) {
        _ref2 = this.debug.pathmaps.list[this.debug.pathmaps.index], map_title = _ref2[0], pathmap = _ref2[1];
        map_val = pathmap[map_xy.toKey()];
        if (map_val === MAX_INT) {
          return;
        } else if (map_val < 0) {
          c = Math.round(255 * (map_val / pathmap.min_value), 0);
        } else {
          c = Math.round(255 * (1 - (map_val / pathmap.max_value)), 0);
        }
        r = map_val === 0 ? 255 : 0;
        this.my_display.draw(xy.x, xy.y, " ", 'black', ROT.Color.toHex([r, c, c]));
        return;
      }
      in_view = this.gamePlayer().canView(map_xy);
      lighted = this.gameLevel().getLightAt(map_xy);
      if (this.debug.fov.monster != null) {
        in_view = this.debug.fov.monster.canView(map_xy);
        lighted = Brew.colors.light_blue;
      }
      memory = this.gamePlayer().getMemoryAt(this.gameLevel().id, map_xy);
      terrain = this.gameLevel().getTerrainAt(map_xy);
      feature = this.gameLevel().getFeatureAt(map_xy);
      overhead = this.gameLevel().getOverheadAt(map_xy);
      fromMemory = false;
      draw = [];
      prelighting_draw = [null, null, null];
      is_lit = (lighted != null) || (this.debug_monster_fov === true);
      can_view_and_lit = (in_view && is_lit) || map_xy.compare(this.gamePlayer().coordinates);
      this.clearDisplayAt(this.my_layer_display, xy);
      if (!can_view_and_lit) {
        if (memory == null) {
          draw = [" ", Brew.colors.black, Brew.colors.black];
        } else {
          fromMemory = true;
          draw = [memory.code, Brew.colors.memory, Brew.colors.memory_bg];
        }
      } else {
        if (terrain == null) {
          debugger;
        }
        item = this.gameLevel().getItemAt(map_xy);
        monster = this.gameLevel().getMonsterAt(map_xy);
        if (monster != null) {
          this.gamePlayer().setMemoryAt(this.gameLevel().id, map_xy, terrain);
          if (monster.hasFlag(Brew.flags.on_fire)) {
            mob_color = Brew.colors.hf_orange;
          } else if (monster.hasFlag(Brew.flags.stunned)) {
            mob_color = Brew.colors.light_blue;
          } else if (monster.hasFlag(Brew.flags.poisoned)) {
            mob_color = Brew.colors.dark_green;
          } else {
            mob_color = terrain.bgcolor;
          }
          draw = [monster.code, monster.color, mob_color];
        } else if (item != null) {
          this.gamePlayer().setMemoryAt(this.gameLevel().id, map_xy, item);
          draw = [item.code, item.color, terrain.bgcolor];
        } else {
          this.gamePlayer().setMemoryAt(this.gameLevel().id, map_xy, terrain);
          draw = [terrain.code, terrain.color, terrain.bgcolor];
          if ((feature != null) && (feature.code != null)) {
            draw[0] = feature.code;
          }
          if ((feature != null) && (feature.color != null)) {
            draw[1] = feature.getColor();
          }
        }
        if (overhead != null) {
          this.my_layer_display.draw(xy.x, xy.y, overhead.code, ROT.Color.toHex(overhead.color));
        }
        prelighting_draw = draw.slice(0);
        if (over_saturate) {
          draw[1] = ROT.Color.multiply(lighted, draw[1]);
          draw[2] = ROT.Color.multiply(lighted, draw[2]);
        } else {
          draw[1] = Brew.utils.minColorRGB(ROT.Color.multiply(lighted, draw[1]), draw[1]);
          draw[2] = Brew.utils.minColorRGB(ROT.Color.multiply(lighted, draw[2]), draw[2]);
        }
      }
      if ((options != null ? options.color_override : void 0) != null) {
        draw[1] = options.color_override;
        draw[2] = Brew.colors.black;
      }
      h = this.highlights[map_xy.toKey()];
      if (h != null) {
        draw[2] = h;
      }
      this.my_display.draw(xy.x, xy.y, draw[0], ROT.Color.toHex(draw[1]), ROT.Color.toHex(draw[2]));
      if ((options != null ? options.color_override : void 0) == null) {
        return this.displayat[map_xy.toKey()] = draw;
      }
    };

    UserInterface.prototype.updatePairDisplay = function(drawings) {
      var bgcolor, code, color, draw_array, key, shade_color, xy;
      shade_color = Brew.colors.pair_shade;
      for (key in drawings) {
        if (!__hasProp.call(drawings, key)) continue;
        draw_array = drawings[key];
        xy = keyToCoord(key);
        code = draw_array[0];
        color = ROT.Color.toHex(ROT.Color.interpolate(draw_array[1], shade_color, 0.5));
        bgcolor = ROT.Color.toHex(ROT.Color.interpolate(draw_array[2], shade_color, 0.5));
        this.my_pair_display.draw(xy.x, xy.y, code, color, bgcolor);
      }
      this.drawings = drawings;
      return true;
    };

    UserInterface.prototype.updatePairDisplayAt = function(xy) {
      var bgcolor, code, color, draw_array, key, shade_color;
      shade_color = Brew.colors.pair_shade;
      key = xy.toKey();
      draw_array = this.drawings[key];
      code = draw_array[0];
      color = ROT.Color.toHex(ROT.Color.interpolate(draw_array[1], shade_color, 0.5));
      bgcolor = ROT.Color.toHex(ROT.Color.interpolate(draw_array[2], shade_color, 0.5));
      this.my_pair_display.draw(xy.x, xy.y, code, color, bgcolor);
      return true;
    };

    UserInterface.prototype.drawHudAll = function() {
      var color, desc, hp, i, maxhp, player, row_start, _i;
      player = this.gamePlayer();
      player.hero_type = "Squire";
      desc = "" + player.name + " <" + player.hero_type + ">";
      this.my_hud_display.drawText(0, 0, player.name);
      row_start = 1;
      maxhp = player.getStat(Brew.stat.health).getMax();
      hp = player.getStat(Brew.stat.health).getCurrent();
      for (i = _i = 1; 1 <= maxhp ? _i <= maxhp : _i >= maxhp; i = 1 <= maxhp ? ++_i : --_i) {
        color = i <= hp ? Brew.colors.red : Brew.colors.normal;
        this.my_hud_display.draw(i - 1, row_start, Brew.unicode.heart, ROT.Color.toHex(color));
      }
      this.drawHudBar(0, 2, 18, player.getStat(Brew.stat.stamina).getCurrent(), player.getStat(Brew.stat.stamina).getMax(), Brew.colors.violet);
      this.drawHudSync();
      return this.drawHudAbility();
    };

    UserInterface.prototype.drawHudAbility = function() {
      var abil_desc, abil_hotkey, black_hex, i, max_width, num_spaces, player, spaces, start_x;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      player = this.gamePlayer();
      if (player.active_ability != null) {
        abil_hotkey = player.abilities.indexOf(player.active_ability) + 1;
        abil_desc = "Using " + (Brew.ability[player.active_ability].name.toUpperCase()) + " (" + abil_hotkey + ")";
      } else {
        abil_desc = "No ability selected";
      }
      start_x = Math.floor(Brew.config.screen_tiles_width / 2);
      max_width = Math.floor(Brew.config.screen_tiles_width / 2);
      num_spaces = max_width - abil_desc.length;
      spaces = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = num_spaces - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      return this.my_hud_display.drawText(start_x, 0, "%c{" + black_hex + "}" + spaces + "%c{white}" + abil_desc);
    };

    UserInterface.prototype.drawHudSync = function() {
      var black_hex, i, max_width, message, num_spaces, spaces, start_x, status_msg;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      if (!this.game.is_paired) {
        status_msg = "Not Connected";
        message = "No Data";
      } else if (this.game.is_paired && !this.game.pair.sync) {
        status_msg = "Connected";
        message = "Awaiting Sync";
      } else {
        status_msg = this.game.pair.sync.status ? "In Sync" : "Out of Sync";
        message = this.game.pair.sync.message;
      }
      start_x = Math.floor(Brew.config.screen_tiles_width / 2);
      max_width = Math.floor(Brew.config.screen_tiles_width / 2);
      num_spaces = max_width - status_msg.length;
      spaces = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = num_spaces - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      this.my_hud_display.drawText(start_x, 1, "%c{" + black_hex + "}" + spaces + "%c{white}" + status_msg);
      num_spaces = max_width - message.length;
      spaces = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = num_spaces - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      return this.my_hud_display.drawText(start_x, 2, "%c{" + black_hex + "}" + spaces + "%c{white}" + message);
    };

    UserInterface.prototype.drawHudBar = function(start_x, start_y, max_tiles, current_amount, max_amount, full_color) {
      var black_hex, fadecolor, i, num_bars, raw_num_bars, remainder, tile, violet_rgb, _i, _ref;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      raw_num_bars = Math.min(1.0, current_amount / max_amount) * max_tiles;
      num_bars = Math.ceil(raw_num_bars);
      remainder = num_bars - raw_num_bars;
      tile = null;
      for (i = _i = 0, _ref = max_tiles - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i === num_bars - 1) {
          if (remainder < 0.25) {
            fadecolor = full_color;
          } else if (remainder < 0.5) {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.25);
          } else if (remainder < 0.75) {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.5);
          } else {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.75);
          }
          this.my_hud_display.draw(start_x + i, start_y, " ", "white", ROT.Color.toHex(full_color));
        } else if (i < num_bars) {
          this.my_hud_display.draw(start_x + i, start_y, " ", "white", ROT.Color.toHex(full_color));
        } else {
          this.my_hud_display.draw(start_x + i, start_y, " ", "white", ROT.Color.toHex(Brew.colors.normal));
        }
      }
      violet_rgb = ROT.Color.toHex(full_color);
      return this.my_hud_display.drawText(start_x + max_tiles + 1, start_y, "%c{" + violet_rgb + "}" + current_amount + "%c{" + black_hex + "}_");
    };

    UserInterface.prototype.drawMessage = function(message) {
      var black_hex, i, max_length, num_spaces, spaces, x, y;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      max_length = Brew.config.screen_tiles_width - 1;
      num_spaces = max_length - message.length;
      spaces = ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= num_spaces ? _i <= num_spaces : _i >= num_spaces; i = 0 <= num_spaces ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      x = 0;
      y = 3 * this.my_tile_height;
      return this.my_hud_display.drawText(0, 3, message + ("%c{" + black_hex + "}" + spaces));
    };

    UserInterface.prototype.drawFooter = function(look_xy) {
      var black_hex, can_view_and_lit, f, i, in_view, is_lit, lighted, m, max_length, memory, message, num_spaces, spaces, t, tap;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      in_view = this.gamePlayer().canView(look_xy);
      lighted = this.gameLevel().getLightAt(look_xy);
      t = this.gameLevel().getTerrainAt(look_xy);
      f = this.gameLevel().getFeatureAt(look_xy);
      i = this.gameLevel().getItemAt(look_xy);
      m = this.gameLevel().getMonsterAt(look_xy);
      memory = this.gamePlayer().getMemoryAt(this.gameLevel().id, look_xy);
      is_lit = lighted != null;
      can_view_and_lit = (in_view && is_lit) || look_xy.compare(this.gamePlayer().coordinates);
      if (!can_view_and_lit) {
        if (memory != null) {
          tap = memory.objtye === "item" ? "a " + memory.name : memory.name;
          message = "You remember seeing " + tap + " there";
        } else {
          message = "You don't see anything";
        }
      } else {
        if ((m != null) && Brew.utils.compareThing(m, this.gamePlayer())) {
          message = "You are standing on " + t.name;
        } else if (m != null) {
          message = "" + m.name;
        } else if (i != null) {
          message = "You see a " + (this.game.getItemNameFromCatalog(i));
        } else {
          message = "You see " + t.name;
        }
      }
      max_length = Brew.config.screen_tiles_width - 1;
      num_spaces = max_length - message.length;
      spaces = ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= num_spaces ? _i <= num_spaces : _i >= num_spaces; i = 0 <= num_spaces ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      return this.my_footer_display.drawText(0, 0, message + ("%c{" + black_hex + "}" + spaces));
    };

    UserInterface.prototype.drawBorders = function(display, color, rectangle) {
      var col_x, h, hex_color, row_y, w, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (rectangle == null) {
        rectangle = {};
      }
      hex_color = ROT.Color.toHex(color);
      h = (_ref = rectangle.height) != null ? _ref : Brew.config.screen_tiles_height - 1;
      w = (_ref1 = rectangle.width) != null ? _ref1 : Brew.config.screen_tiles_width - 1;
      x = (_ref2 = rectangle.x) != null ? _ref2 : 0;
      y = (_ref3 = rectangle.y) != null ? _ref3 : 0;
      for (row_y = _i = y, _ref4 = y + h; y <= _ref4 ? _i <= _ref4 : _i >= _ref4; row_y = y <= _ref4 ? ++_i : --_i) {
        display.draw(x, row_y, "|", hex_color);
        display.draw(x + w, row_y, "|", hex_color);
      }
      for (col_x = _j = x, _ref5 = x + w; x <= _ref5 ? _j <= _ref5 : _j >= _ref5; col_x = x <= _ref5 ? ++_j : --_j) {
        display.draw(col_x, y, Brew.unicode.horizontal_line, hex_color);
        display.draw(col_x, y + h, Brew.unicode.horizontal_line, hex_color);
      }
      display.draw(x, y, Brew.unicode.corner_topleft, hex_color);
      display.draw(x, y + h, Brew.unicode.corner_bottomleft, hex_color);
      display.draw(x + w, y, Brew.unicode.corner_topright, hex_color);
      return display.draw(x + w, y + h, Brew.unicode.corner_bottomright, hex_color);
    };

    UserInterface.prototype.clearDisplay = function(display) {
      return display._backend._context.clearRect(0, 0, display.getContainer().width, display.getContainer().height);
    };

    UserInterface.prototype.clearPopupDisplay = function() {
      return this.clearDisplay(this.my_popup_display);
    };

    UserInterface.prototype.clearLayerDisplay = function() {
      return this.clearDisplay(this.my_layer_display);
    };

    UserInterface.prototype.clearDialogDisplay = function() {
      return this.clearDisplay(this.my_dialog_display);
    };

    UserInterface.prototype.clearDisplayAt = function(display, xy) {
      var x, y;
      x = xy.x * this.my_tile_width;
      y = xy.y * this.my_tile_height;
      return display._backend._context.clearRect(x, y, this.my_tile_width, this.my_tile_height);
    };

    UserInterface.prototype.initLayerDisplay = function() {
      var pos;
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_layer").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearLayerDisplay();
      return $("#id_div_layer").show();
    };

    UserInterface.prototype.initDialogDisplay = function() {
      var pos;
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_dialog").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearDialogDisplay();
      return $("#id_div_dialog").show();
    };

    UserInterface.prototype.showInfoScreen = function(width_tiles, height_tiles) {
      var isCentered, offset_height_tiles, offset_width_tiles, pos;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      isCentered = true;
      offset_width_tiles = Math.floor((Brew.config.screen_tiles_width - width_tiles) / 2);
      offset_height_tiles = Math.floor((Brew.config.screen_tiles_height - height_tiles) / 2);
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: offset_width_tiles,
        y: offset_height_tiles,
        width: width_tiles,
        height: height_tiles
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(offset_width_tiles + 1, offset_height_tiles + 1, this.game.getItemNameFromCatalog(this.popup.item));
      this.my_popup_display.drawText(offset_width_tiles + 1, offset_height_tiles + 3, this.popup.item.description, width_tiles - 1);
      return this.input_handler = "popup_to_dismiss";
    };

    UserInterface.prototype.showInventory = function() {
      var action_word, apply, apply_list, color_hotkey_hex, color_text_hex, color_title_hex, context, filter_fn, inventory_title, item, key, offset_info, offset_xy, pos, terrain, text, y, _i, _len, _ref;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      color_title_hex = ROT.Color.toHex(Brew.colors.inventorymenu.title);
      color_text_hex = ROT.Color.toHex(Brew.colors.inventorymenu.text);
      color_hotkey_hex = ROT.Color.toHex(Brew.colors.inventorymenu.hotkey);
      this.drawBorders(this.my_popup_display, Brew.colors.inventorymenu.border);
      $("#id_div_popup").show();
      if (this.popup.context) {
        action_word = this.popup.context === "apply" ? "use" : this.popup.context;
        context = action_word[0].toUpperCase() + action_word.slice(1);
        inventory_title = context + " what?";
      } else {
        inventory_title = "Ye Inventory";
      }
      filter_fn = (function() {
        switch (this.popup.context) {
          case "apply":
            return (function(_this) {
              return function(i) {
                return _this.game.canApply(i);
              };
            })(this);
          case "remove":
            return (function(_this) {
              return function(i) {
                return _this.game.canRemove(i);
              };
            })(this);
          case "equip":
            return (function(_this) {
              return function(i) {
                return _this.game.canEquip(i);
              };
            })(this);
          case "drop":
            return (function(_this) {
              return function(i) {
                return _this.game.canDrop(i);
              };
            })(this);
          case "give":
            return (function(_this) {
              return function(i) {
                return _this.game.canGive(i);
              };
            })(this);
          case "throw":
            return (function(_this) {
              return function(i) {
                return false;
              };
            })(this);
          default:
            return (function(_this) {
              return function(i) {
                return true;
              };
            })(this);
        }
      }).call(this);
      this.my_popup_display.drawText(1, 1, ("%c{" + color_title_hex + "}") + inventory_title);
      y = 2;
      _ref = this.gamePlayer().inventory.items;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        item = _ref[key];
        if (!filter_fn(item)) {
          continue;
        }
        this.my_popup_display.draw(1, y, item.inv_key_lower, color_hotkey_hex);
        this.my_popup_display.draw(3, y, item.code, ROT.Color.toHex(item.color));
        text = ("%c{" + color_text_hex + "}") + this.game.getItemNameFromCatalog(item);
        if (item.equip) {
          text += " (Equipped)";
        }
        this.my_popup_display.drawText(5, y, text);
        y += 1;
      }
      if (this.popup.context === "apply") {
        apply_list = this.game.getApplicableTerrain(this.gamePlayer());
        this.popup.terrain = {};
        y += 2;
        for (_i = 0, _len = apply_list.length; _i < _len; _i++) {
          apply = apply_list[_i];
          offset_xy = apply[0];
          terrain = apply[1];
          offset_info = Brew.utils.getOffsetInfo(offset_xy);
          this.popup.terrain[offset_info.arrow_keycode] = terrain;
          this.my_popup_display.draw(1, y, offset_info.unicode, ROT.Color.toHex(Brew.colors.white));
          this.my_popup_display.draw(3, y, terrain.code, ROT.Color.toHex(terrain.color));
          text = ("%c{" + color_text_hex + "}") + terrain.name;
          this.my_popup_display.drawText(5, y, text);
          y += 1;
        }
      }
      this.popup.inventory = this.gamePlayer().inventory;
      return this.input_handler = "inventory";
    };

    UserInterface.prototype.showItemMenu = function(item) {
      var action, action_name, actions, can_do_it, color_hotkey_hex, color_text_hex, color_title_hex, extra_desc, i;
      this.clearPopupDisplay();
      color_title_hex = ROT.Color.toHex(Brew.colors.itemmenu.title);
      color_text_hex = ROT.Color.toHex(Brew.colors.itemmenu.text);
      color_hotkey_hex = ROT.Color.toHex(Brew.colors.itemmenu.hotkey);
      this.drawBorders(this.my_popup_display, Brew.colors.itemmenu.border);
      this.my_popup_display.drawText(1, 1, ("%c{" + color_title_hex + "}") + this.game.getItemNameFromCatalog(item));
      this.my_popup_display.drawText(1, 3, ("%c{" + color_title_hex + "}") + this.game.getItemDescription(item), 38);
      extra_desc = "";
      if (item.group === Brew.groups.WEAPON) {
        extra_desc = "Damage: " + item.damage;
      } else if (item.group === Brew.groups.ARMOR) {
        extra_desc = "Block: " + item.block;
      } else if (item.group === Brew.groups.HAT) {
        extra_desc = "Hats are just decorative for now";
      }
      this.my_popup_display.drawText(1, 8, extra_desc, 38);
      actions = {
        apply: this.game.canApply(item),
        equip: this.game.canEquip(item),
        remove: this.game.canRemove(item),
        drop: true,
        "throw": false,
        give: true
      };
      i = 0;
      for (action in actions) {
        if (!__hasProp.call(actions, action)) continue;
        can_do_it = actions[action];
        if (can_do_it) {
          action_name = action === "apply" ? "use" : action;
          this.my_popup_display.drawText(2, 10 + i, ("%c{" + color_hotkey_hex + "}") + action_name[0].toUpperCase() + ("%c{" + color_text_hex + "}") + action_name.slice(1));
          i += 1;
        }
      }
      this.popup.item = item;
      this.popup.actions = actions;
      return this.input_handler = "item_menu";
    };

    UserInterface.prototype.showChat = function() {
      var pos;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: 0,
        y: 0,
        width: Brew.config.screen_tiles_width - 1,
        height: 4
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(1, 1, "Say what? <use delete to erase>");
      this.my_popup_display.drawText(1, 2, "%c{cyan}" + this.popup.text);
      this.my_popup_display.drawText(1, 4, "ENTER sends - press ESCAPE to cancel");
      return this.input_handler = "chat";
    };

    UserInterface.prototype.showDied = function() {
      var pos;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: 0,
        y: 0,
        width: Brew.config.screen_tiles_width - 1,
        height: 4
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(1, 1, "Congratulations, you have died!");
      this.my_popup_display.drawText(1, 2, "Press ENTER to start a new game");
      this.my_popup_display.drawText(1, 3, "Press ESC to return to the menu");
      return this.input_handler = "died";
    };

    UserInterface.prototype.showVictory = function() {
      var pos;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: 0,
        y: 0,
        width: Brew.config.screen_tiles_width - 1,
        height: 12
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(1, 1, "Congratulations, you defeated the Time Master");
      this.my_popup_display.drawText(1, 2, "and saved the realm.");
      this.my_popup_display.drawText(1, 4, "I really wish I had a better victory screen for you, but it is day 7 and 4 hours to go so this is all you get! Oh, and a database entry! Thanks for playing!", 38);
      this.my_popup_display.drawText(1, 10, "Press ENTER to start a new game");
      this.my_popup_display.drawText(1, 11, "Press ESC to return to the menu");
      return this.input_handler = "died";
    };

    UserInterface.prototype.showHelp = function() {
      var black_hex, pos;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: 0,
        y: 0,
        width: Brew.config.screen_tiles_width - 1,
        height: Brew.config.screen_tiles_height - 1
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(1, 1, Brew.helptext, 40);
      return this.input_handler = "popup_to_dismiss";
    };

    UserInterface.prototype.showMonsterInfo = function() {
      var black_hex, desc, flag, i, pos, _i, _len, _ref;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      this.drawBorders(this.my_popup_display, Brew.colors.white, {
        x: 0,
        y: 0,
        width: Brew.config.screen_tiles_width - 1,
        height: Brew.config.screen_tiles_height - 1
      });
      $("#id_div_popup").show();
      this.my_popup_display.drawText(1, 1, this.popup.monster.name, 38);
      desc = this.popup.monster.description != null ? this.popup.monster.description : "No description";
      this.my_popup_display.drawText(1, 3, desc, 38);
      i = 0;
      _ref = this.popup.monster.getFlags();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        flag = _ref[_i];
        desc = Brew.flagDesc[flag];
        this.my_popup_display.drawText(1, 8 + i, desc, 38);
        i += 1;
      }
      return this.input_handler = "popup_to_dismiss";
    };

    UserInterface.prototype.showTimeOrbScreen = function() {
      var color_hotkey_hex, color_text_hex, color_title_hex, row_start;
      this.clearPopupDisplay();
      color_title_hex = ROT.Color.toHex(Brew.colors.itemmenu.title);
      color_text_hex = ROT.Color.toHex(Brew.colors.itemmenu.text);
      color_hotkey_hex = ROT.Color.toHex(Brew.colors.itemmenu.hotkey);
      this.drawBorders(this.my_popup_display, Brew.colors.itemmenu.border);
      $("#id_div_popup").show();
      this.my_popup_display.drawText(2, 1, "The TIME ORB pulses and swirls");
      this.my_popup_display.drawText(2, 2, "mysteriously.");
      this.my_popup_display.drawText(2, 4, "You can use it to help your partner");
      this.my_popup_display.drawText(2, 5, "across the splintered reality within");
      this.my_popup_display.drawText(2, 6, "the Caves:");
      row_start = 8;
      this.my_popup_display.drawText(2, row_start, "- Incoming -");
      this.my_popup_display.drawText(2, row_start + 1, "(1) Fireball");
      row_start += 2;
      this.my_popup_display.drawText(2, row_start, "- Send -");
      this.my_popup_display.drawText(2, row_start + 1, "(!) Send Item");
      this.my_popup_display.drawText(2, row_start + 2, "(@) Send Monster");
      return this.input_handler = "timeorb";
    };

    UserInterface.prototype.showAbilities = function() {
      var abil, color_hotkey_hex, color_text_hex, color_title_hex, idx, pos, row_start, _i, _len, _ref;
      this.drawDisplayAll({
        color_override: [50, 50, 50]
      });
      pos = $(this.my_display.getContainer()).position();
      $("#id_div_popup").css({
        position: "absolute",
        top: pos.top,
        left: pos.left
      });
      this.clearPopupDisplay();
      color_title_hex = ROT.Color.toHex(Brew.colors.itemmenu.title);
      color_text_hex = ROT.Color.toHex(Brew.colors.itemmenu.text);
      color_hotkey_hex = ROT.Color.toHex(Brew.colors.itemmenu.hotkey);
      this.drawBorders(this.my_popup_display, Brew.colors.itemmenu.border);
      $("#id_div_popup").show();
      this.my_popup_display.drawText(2, 1, "Abilities and Spells");
      row_start = 3;
      _ref = this.gamePlayer().getAbilities();
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        abil = _ref[idx];
        this.my_popup_display.drawText(2, row_start + idx, "(" + (idx + 1) + ") " + Brew.ability[abil].name);
        this.my_popup_display.drawText(2, row_start + idx + 1, "" + Brew.ability[abil].description);
        this.my_popup_display.drawText(2, row_start + idx + 2, Brew.ability[abil].pair ? "Can be used to help allies" : "");
        row_start += 3;
      }
      return this.input_handler = "abilities";
    };

    UserInterface.prototype.inputGameplay = function(keycode, shift_key) {
      var offset_xy;
      if (__indexOf.call(Brew.keymap.MOVE_LEFT, keycode) >= 0) {
        offset_xy = Brew.directions.w;
        return this.game.movePlayer(offset_xy);
      } else if (__indexOf.call(Brew.keymap.MOVE_RIGHT, keycode) >= 0) {
        offset_xy = Brew.directions.e;
        return this.game.movePlayer(offset_xy);
      } else if (__indexOf.call(Brew.keymap.MOVE_UP, keycode) >= 0) {
        offset_xy = Brew.directions.n;
        return this.game.movePlayer(offset_xy);
      } else if (__indexOf.call(Brew.keymap.MOVE_DOWN, keycode) >= 0) {
        offset_xy = Brew.directions.s;
        return this.game.movePlayer(offset_xy);
      } else if (__indexOf.call(Brew.keymap.GENERIC_ACTION, keycode) >= 0) {
        return this.game.doPlayerAction();
      } else if (__indexOf.call(Brew.keymap.TALK, keycode) >= 0) {
        this.popup.context = "chat";
        this.popup.text = "";
        return this.showChat();
      } else if (__indexOf.call(Brew.keymap.USE, keycode) >= 0) {
        this.popup.context = "apply";
        return this.showInventory();
      } else if (__indexOf.call(Brew.keymap.INVENTORY, keycode) >= 0) {
        return this.showInventory();
      } else if (__indexOf.call(Brew.keymap.SHOW_ABILITIES, keycode) >= 0) {
        return this.showAbilities();
      } else if (__indexOf.call(Brew.keymap.HELP, keycode) >= 0) {
        return this.showHelp();
      } else if (__indexOf.call(Brew.keymap.DEBUG, keycode) >= 0) {
        return this.debugAtCoords();
      } else if (__indexOf.call(Brew.keymap.ABILITY_HOTKEY, keycode) >= 0) {
        return this.game.doPlayerSelectAbility(keycode);
      }
    };

    UserInterface.prototype.inputAbilities = function(keycode) {
      if (keycode === 49 || keycode === 50 || keycode === 51 || keycode === 52 || keycode === 53 || keycode === 54) {
        this.game.doPlayerSelectAbility(keycode);
      }
      $("#id_div_popup").hide();
      this.drawDisplayAll();
      this.popup = {};
      return this.input_handler = null;
    };

    UserInterface.prototype.inputInventory = function(keycode) {
      var inv_key, item;
      if ((this.popup.terrain != null) && keycode in this.popup.terrain) {
        this.game.doPlayerApplyTerrain(this.popup.terrain[keycode], false);
      }
      inv_key = String.fromCharCode(keycode);
      if (__indexOf.call(this.popup.inventory.getKeys(), inv_key) >= 0) {
        item = this.popup.inventory.getItem(inv_key);
        if (this.popup.context === "drop") {
          this.game.doPlayerDrop(item);
        } else if (this.popup.context === "equip") {
          this.game.doPlayerEquip(item);
        } else if (this.popup.context === "remove") {
          this.game.doPlayerRemove(item);
        } else if (this.popup.context === "give") {
          this.game.doPlayerGive(item);
        } else if (this.popup.context === "apply") {
          this.game.doPlayerApply(item, inv_key);
        } else if (this.popup.context === "throw") {
          this.promptThrow(item, inv_key);
        } else {
          this.showItemMenu(item);
          return true;
        }
      }
      $("#id_div_popup").hide();
      this.drawDisplayAll();
      this.popup = {};
      return this.input_handler = null;
    };

    UserInterface.prototype.inputItemMenu = function(keycode) {
      if (keycode === 85) {
        if (this.popup.actions.apply) {
          this.game.doPlayerApply(this.popup.item, keycode);
        } else {
          console.log("You can't apply that");
        }
      } else if (keycode === 68) {
        if (this.popup.actions.drop) {
          this.game.doPlayerDrop(this.popup.item);
        } else {
          console.log("you cant drop that");
        }
      } else if (keycode === 71) {
        if (this.popup.actions.give) {
          this.game.doPlayerGive(this.popup.item);
        } else {
          console.log("you cant drop that");
        }
      } else if (keycode === 69) {
        if (this.popup.actions.equip) {
          this.game.doPlayerEquip(this.popup.item);
        } else {
          console.log("you cant equip that ");
        }
      } else if (keycode === 84) {
        if (this.popup.actions["throw"]) {
          this.promptThrow(this.popup.item);
        } else {
          console.log("you cant THROW THAT");
        }
      } else if (keycode === 82) {
        if (this.popup.actions.remove) {
          this.game.doPlayerRemove(this.popup.item);
        } else {
          console.log("you cant remove that!");
        }
      } else {
        this.showInventory();
        return true;
      }
      $("#id_div_popup").hide();
      this.drawDisplayAll();
      this.popup = {};
      return this.input_handler = null;
    };

    UserInterface.prototype.inputPopupToDismiss = function(keycode) {
      if (keycode === 32 || keycode === 13 || keycode === 27) {
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        return this.input_handler = null;
      }
    };

    UserInterface.prototype.inputDied = function(keycode) {
      if (keycode === 13) {
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        this.input_handler = null;
        return window.location.replace("http://www.dungeondual.com/creategame/");
      } else if (keycode === 27) {
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        this.input_handler = null;
        return window.location.replace("http://www.dungeondual.com/");
      }
    };

    UserInterface.prototype.inputChat = function(keycode, shiftKey) {
      var letter;
      if (keycode === 13) {
        this.game.socket.sendChat(this.popup.text);
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        return this.input_handler = null;
      } else if (keycode === 27) {
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        return this.input_handler = null;
      } else if (keycode === 46) {
        if (this.popup.text) {
          this.popup.text = this.popup.text.slice(0, +(this.popup.text.length - 2) + 1 || 9e9);
          return this.showChat();
        }
      } else {
        letter = Brew.utils.mapKeyPressToActualCharacter(keycode, shiftKey);
        if (this.popup.text.length < (Brew.config.screen_tiles_width - 2)) {
          this.popup.text += letter;
        }
        return this.showChat();
      }
    };

    UserInterface.prototype.inputTimeOrb = function(keycode, shiftKey) {
      if (keycode === 32 || keycode === 13 || keycode === 27) {
        $("#id_div_popup").hide();
        this.drawDisplayAll();
        this.popup = {};
        return this.input_handler = null;
      }
    };

    UserInterface.prototype.mouseDown = function(grid_obj_xy, button, shift_key) {
      var map_xy, player, target_is_player, target_mob;
      map_xy = this.my_view.add(grid_obj_xy);
      player = this.gamePlayer();
      target_mob = this.gameLevel().getMonsterAt(map_xy);
      target_is_player = (target_mob != null) && Brew.utils.compareThing(target_mob, player);
      if (target_is_player) {
        return false;
      } else {
        if (shift_key) {
          this.game.debugClick(map_xy);
        } else {
          this.game.doPlayerClick(map_xy);
        }
      }
      return this.game.lastKeypress = new Date();
    };

    UserInterface.prototype.mouseLongClick = function(grid_obj_xy, button, shift_key) {
      var m, map_xy;
      map_xy = this.my_view.add(grid_obj_xy);
      m = this.gameLevel().getMonsterAt(map_xy);
      if (m != null) {
        this.popup.monster = m;
        return this.showMonsterInfo();
      }
    };

    UserInterface.prototype.mouseGainFocus = function(grid_obj_xy) {
      var grid_xy, map_xy;
      grid_manager.drawBorderAt(grid_obj_xy, 'white');
      grid_xy = new Coordinate(grid_obj_xy.x, grid_obj_xy.y);
      map_xy = this.my_view.add(grid_xy);
      this.drawFooter(map_xy);
      if (this.game.my_player.active_ability != null) {
        if (this.game.abil.checkUseAt(this.game.my_player.active_ability, map_xy)) {
          this.highlights[map_xy.toKey()] = Brew.colors.green;
          return this.drawMapAt(map_xy);
        }
      }
    };

    UserInterface.prototype.mouseLeaveFocus = function(grid_obj_xy) {
      var grid_xy, map_xy;
      grid_xy = new Coordinate(grid_obj_xy.x, grid_obj_xy.y);
      map_xy = this.my_view.add(grid_xy);
      delete this.highlights[grid_xy.toKey()];
      return this.drawDisplayAt(grid_xy);
    };

    UserInterface.prototype.mouseDownPair = function(grid_obj_xy, button, shift_key) {
      var pair_map_xy;
      if (!this.game.is_paired) {
        return false;
      }
      pair_map_xy = this.game.pair.view.xy.add(grid_obj_xy);
      this.game.doPlayerPairClick(pair_map_xy);
      return true;
    };

    UserInterface.prototype.mouseGainFocusPair = function(grid_obj_xy) {
      var drawing, pair_map_xy;
      if (!this.game.is_paired) {
        return false;
      }
      pair_grid_manager.drawBorderAt(grid_obj_xy, 'white');
      pair_map_xy = this.game.pair.view.xy.add(grid_obj_xy);
      if (this.game.my_player.active_ability != null) {
        if (this.game.abil.checkPairUseAt(this.game.my_player.active_ability, pair_map_xy)) {
          drawing = this.displayat[pair_map_xy.toKey()];
          return this.my_pair_display.draw(grid_obj_xy.x, grid_obj_xy.y, drawing[0], drawing[1], "green");
        }
      }
    };

    UserInterface.prototype.mouseLeaveFocusPair = function(grid_obj_xy) {
      var grid_xy;
      if (!this.game.is_paired) {
        return false;
      }
      grid_xy = new Coordinate(grid_obj_xy.x, grid_obj_xy.y);
      return this.updatePairDisplayAt(grid_xy);
    };

    UserInterface.prototype.showDialogAbove = function(loc_xy, msg, color_rgb) {
      var above_xy;
      above_xy = loc_xy.y === 0 ? loc_xy.add(new Coordinate(0, 1)) : loc_xy.subtract(new Coordinate(0, 1));
      return this.showDialog(above_xy, msg, color_rgb);
    };

    UserInterface.prototype.showDialog = function(loc_xy, msg, color_rgb) {
      var color_hex, far_right, offset, x, y;
      if (color_rgb == null) {
        color_rgb = Brew.colors.white;
      }
      color_hex = ROT.Color.toHex(color_rgb);
      far_right = loc_xy.x + msg.length;
      if (far_right >= Brew.config.screen_tiles_width) {
        offset = far_right - Brew.config.screen_tiles_width;
        loc_xy = loc_xy.subtract(new Coordinate(offset, 0));
      }
      this.my_dialog_display.drawText(loc_xy.x, loc_xy.y, "%c{" + color_hex + "}" + msg);
      x = loc_xy.x * this.my_tile_width;
      y = loc_xy.y * this.my_tile_height;
      return setTimeout((function(_this) {
        return function() {
          return _this.my_dialog_display._backend._context.clearRect(x, y, _this.my_tile_width * msg.length, _this.my_tile_height);
        };
      })(this), 2000);
    };

    UserInterface.prototype.debugMonsterFov = function() {
      var current_idx, fov_monster, indices, m, monsters, new_idx;
      monsters = this.gameLevel().getMonsters();
      fov_monster = null;
      if (monsters.length === 0) {
        console.log("No monsters on the level");
      }
      if (this.debug.fov.monster == null) {
        this.debug.fov.monster = monsters[0];
      } else {
        indices = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = monsters.length; _i < _len; _i++) {
            m = monsters[_i];
            _results.push(m.id);
          }
          return _results;
        })();
        current_idx = indices.indexOf(this.debug.fov.monster.id);
        new_idx = current_idx + 1;
        if (new_idx > monsters.length) {
          this.debug.fov = {};
        } else {
          this.debug.fov.monster = monsters[new_idx];
        }
      }
      return this.drawDisplayAll();
    };

    UserInterface.prototype.debugPathMaps = function() {
      var arg, key, monster, pathmap, title, _i, _len, _ref, _ref1, _ref2;
      if (this.debug.pathmaps.list == null) {
        this.debug.pathmaps.list = [];
        this.debug.pathmaps.index = -1;
        _ref = this.gameLevel().getMonsters();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          monster = _ref[_i];
          _ref1 = monster.pathmaps;
          for (key in _ref1) {
            if (!__hasProp.call(_ref1, key)) continue;
            pathmap = _ref1[key];
            title = "" + monster.name + " " + monster.id + " " + key;
            this.debug.pathmaps.list.push([title, pathmap]);
          }
        }
        _ref2 = this.game.pathmaps;
        for (key in _ref2) {
          if (!__hasProp.call(_ref2, key)) continue;
          pathmap = _ref2[key];
          title = "game " + key;
          this.debug.pathmaps.list.push([title, pathmap]);
        }
      }
      arg = this.debug.pathmaps.index;
      delete this.debug.pathmaps["index"];
      this.drawDisplayAll();
      this.debug.pathmaps.index = arg;
      this.debug.pathmaps.index += 1;
      if (this.debug.pathmaps.index === this.debug.pathmaps.list.length) {
        this.debug.pathmaps = {};
      } else {
        console.log("showing pathmap: " + this.debug.pathmaps.list[this.debug.pathmaps.index][0]);
      }
      return this.drawDisplayAll();
    };

    UserInterface.prototype.debugAtCoords = function() {
      var f, grid_obj_xy, i, key, m, map_xy, o;
      grid_obj_xy = grid_manager.getLastVisitGrid();
      map_xy = coordFromObject(grid_obj_xy);
      console.log("grid xy", grid_obj_xy);
      console.log("map xy", map_xy);
      key = map_xy.toKey();
      console.log("key", key);
      console.log("terrain", this.gameLevel().getTerrainAt(map_xy));
      f = this.gameLevel().getFeatureAt(map_xy);
      console.log("feature", f != null ? f : "none");
      i = this.gameLevel().getItemAt(map_xy);
      console.log("item", i != null ? i : "none");
      m = this.gameLevel().getMonsterAt(map_xy);
      console.log("monster", m != null ? m : "none");
      o = this.gameLevel().getOverheadAt(map_xy);
      console.log("overhead", o != null ? o : "none");
      console.log("can_view", this.gamePlayer().canView(map_xy));
      console.log("light", this.gameLevel().getLightAt(map_xy));
      console.log("light (NoA)", this.gameLevel().getLightAt_NoAmbient(map_xy));
      return true;
    };

    return UserInterface;

  })();

}).call(this);

//# sourceMappingURL=brew_interface.map
