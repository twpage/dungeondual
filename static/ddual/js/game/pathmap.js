// Generated by CoffeeScript 1.7.1
(function() {
  var initPathMap, solvePathMap,
    __hasProp = {}.hasOwnProperty;

  initPathMap = function(dungeon) {
    var pathmap, x, y, _i, _j, _ref, _ref1;
    pathmap = {};
    for (x = _i = -1, _ref = dungeon.width; -1 <= _ref ? _i <= _ref : _i >= _ref; x = -1 <= _ref ? ++_i : --_i) {
      for (y = _j = -1, _ref1 = dungeon.height; -1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = -1 <= _ref1 ? ++_j : --_j) {
        pathmap[keyFromXY(x, y)] = MAX_INT;
      }
    }
    return pathmap;
  };

  solvePathMap = function(pathmap, passable_lst) {
    var grid_key, key, made_changes, max_value, min_value, neighbor_key, neighbor_key_lst, neighbor_val, passes, value, _i, _j, _len, _len1;
    made_changes = true;
    passes = 1;
    while (made_changes) {
      made_changes = false;
      for (_i = 0, _len = passable_lst.length; _i < _len; _i++) {
        grid_key = passable_lst[_i];
        neighbor_key_lst = getAdjacentKeys(grid_key);
        neighbor_val = MAX_INT;
        for (_j = 0, _len1 = neighbor_key_lst.length; _j < _len1; _j++) {
          neighbor_key = neighbor_key_lst[_j];
          neighbor_val = Math.min(neighbor_val, pathmap[neighbor_key]);
        }
        if ((pathmap[grid_key] - neighbor_val) >= 2) {
          pathmap[grid_key] = neighbor_val + 1;
          made_changes = true;
        }
      }
      passes += 1;
    }
    max_value = null;
    min_value = null;
    for (key in pathmap) {
      if (!__hasProp.call(pathmap, key)) continue;
      value = pathmap[key];
      if (!value || value === MAX_INT) {
        continue;
      }
      max_value = !max_value ? value : Math.max(max_value, value);
      min_value = !min_value ? value : Math.min(min_value, value);
    }
    pathmap.max_value = max_value;
    pathmap.min_value = min_value;
    return pathmap;
  };

  window.Brew.PathMap = {
    createGenericMapToPlayer: function(dungeon, player_xy, max_distance, options) {
      var avail_key_list, key, mob, passable_lst, pathmap, use_flying, w, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      use_flying = (_ref = options.use_flying) != null ? _ref : false;
      pathmap = initPathMap(dungeon);
      if (use_flying) {
        avail_key_list = dungeon.navigation.fly.key;
      } else {
        avail_key_list = dungeon.navigation.walk.key;
      }
      passable_lst = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = avail_key_list.slice(0);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          w = _ref1[_i];
          if (Brew.utils.dist2d(player_xy, keyToCoord(w)) < max_distance) {
            _results.push(w);
          }
        }
        return _results;
      })();
      _ref1 = dungeon.monsters;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        mob = _ref1[key];
        if (mob.group === "player") {
          pathmap[key] = 0;
          player_xy = keyToCoord(key);
        } else if (mob.hasFlag(Brew.flags.is_immobile)) {
          passable_lst.remove(Number(key));
        }
      }
      return solvePathMap(pathmap, passable_lst);
    },
    createMapToPlayer: function(dungeon, player_xy, focus_monster, max_distance) {
      var avail_key_list, key, mob, passable_lst, pathmap, w, _ref;
      pathmap = initPathMap(dungeon);
      if (focus_monster.hasFlag(Brew.flags.is_flying)) {
        avail_key_list = dungeon.navigation.fly.key;
      } else {
        avail_key_list = dungeon.navigation.walk.key;
      }
      passable_lst = (function() {
        var _i, _len, _ref, _results;
        _ref = avail_key_list.slice(0);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          if (Brew.utils.dist2d(player_xy, keyToCoord(w)) < max_distance) {
            _results.push(w);
          }
        }
        return _results;
      })();
      _ref = dungeon.monsters;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        mob = _ref[key];
        if (mob.group === "player") {
          pathmap[key] = 0;
          player_xy = keyToCoord(key);
        } else if (!Brew.utils.compareThing(mob, focus_monster)) {
          passable_lst.remove(Number(key));
        }
      }
      return solvePathMap(pathmap, passable_lst);
    },
    createMapFromPlayer: function(dungeon, player_xy, focus_monster, to_map, max_distance) {
      var avail_key_list, escape_factor, from_map, key, map_key, map_value, mob, passable_lst, w, _ref;
      escape_factor = -1.2;
      from_map = {};
      if (focus_monster.hasFlag(Brew.flags.is_flying)) {
        avail_key_list = dungeon.navigation.fly.key;
      } else {
        avail_key_list = dungeon.navigation.walk.key;
      }
      passable_lst = (function() {
        var _i, _len, _ref, _results;
        _ref = avail_key_list.slice(0);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          if (Brew.utils.dist2d(player_xy, keyToCoord(w)) < max_distance) {
            _results.push(w);
          }
        }
        return _results;
      })();
      for (map_key in to_map) {
        if (!__hasProp.call(to_map, map_key)) continue;
        map_value = to_map[map_key];
        from_map[map_key] = map_value === MAX_INT ? map_value : Math.ceil(map_value * escape_factor);
      }
      _ref = dungeon.monsters;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        mob = _ref[key];
        if (mob.group === "player") {
          from_map[key] = MAX_INT;
        } else if (!Brew.utils.compareThing(mob, focus_monster)) {
          passable_lst.remove(Number(key));
        }
      }
      from_map = solvePathMap(from_map, passable_lst);
      return from_map;
    },
    getDownhillNeighbor: function(pathmap, location_xy) {
      var lowest_value, lowest_xy, neighbor_xy, temp_value, _i, _len, _ref;
      lowest_xy = location_xy;
      lowest_value = pathmap[location_xy.toKey()];
      _ref = location_xy.getSurrounding();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        neighbor_xy = _ref[_i];
        temp_value = pathmap[neighbor_xy.toKey()];
        if (temp_value < lowest_value) {
          lowest_value = temp_value;
          lowest_xy = neighbor_xy;
        }
      }
      return {
        xy: lowest_xy,
        value: lowest_value
      };
    }
  };

}).call(this);

//# sourceMappingURL=pathmap.map
