// Generated by CoffeeScript 1.7.1
(function() {
  window.Brew.Intel = (function() {
    function Intel(game) {
      this.game = game;
      this.id = null;
    }

    Intel.prototype.msg = function(text) {
      return this.game.msg(text);
    };

    Intel.prototype.doMonsterTurn = function(monster) {
      var result;
      if (monster.agent) {
        return Brew.Agent.doAgentTurn(this.game, this.game.my_level, monster);
      }
      if (monster.hasFlag(Brew.flags.stunned)) {
        return false;
      }
      this.updateState(monster);
      result = this.getAction(monster);
      monster.last_xy = monster.coordinates;
      this.game.execMonsterTurnResult(monster, result);
      return true;
    };

    Intel.prototype.updateState = function(monster) {
      var horde_sense_player, me_sense_player, sense_player, verb;
      me_sense_player = monster.hasKnowledgeOf(this.game.my_player);
      horde_sense_player = monster.horde != null ? monster.horde.hasKnowledgeOf(this.game.my_player) : false;
      sense_player = me_sense_player || horde_sense_player;
      if (monster.status !== Brew.monster_status.ESCAPE && monster.hasFlag(Brew.flags.flees_when_wounded)) {
        if (monster.hp < monster.maxhp) {
          this.msg(monster.name + " flees!");
          monster.status = Brew.monster_status.ESCAPE;
          return true;
        }
      }
      if (monster.status === Brew.monster_status.SLEEP) {

      } else if (monster.status === Brew.monster_status.WANDER) {
        if (sense_player) {
          verb = " spots ";
          this.game.ui.showDialogAbove(monster.coordinates, Brew.Messages.getRandom("alarm"), Brew.colors.red);
          monster.giveup = 0;
          monster.status = Brew.monster_status.HUNT;
        }
      } else if (monster.status === Brew.monster_status.HUNT) {
        if (!sense_player) {
          monster.giveup = (monster != null ? monster.giveup : void 0) ? monster.giveup + 1 : 1;
          if (monster.giveup > 4) {
            monster.giveup = 0;
            monster.status = Brew.monster_status.WANDER;
          }
        } else {
          monster.last_player_xy = this.game.my_player.coordinates;
        }
      } else if (monster.status === Brew.monster_status.ESCAPE) {
        if (monster.hp === monster.maxhp) {
          monster.status = Brew.monster_status.HUNT;
        }
      }
      return true;
    };

    Intel.prototype.getAction = function(monster) {
      var decision, horde_sense_player, is_immobile, keeps_distance, me_sense_player, monster_at, result, sense_player, special_ability;
      me_sense_player = monster.hasKnowledgeOf(this.game.my_player);
      horde_sense_player = monster.horde != null ? monster.horde.hasKnowledgeOf(this.game.my_player) : false;
      sense_player = me_sense_player || horde_sense_player;
      is_immobile = monster.hasFlag(Brew.flags.is_immobile);
      result = {
        action: null,
        xy: monster.coordinates,
        target: null
      };
      if (monster.status === Brew.monster_status.SLEEP) {
        result.action = "sleep";
      } else if (monster.status === Brew.monster_status.WANDER) {
        if (monster.giveup > 4 || ((monster.wander_xy != null) && monster.coordinates.compare(monster.wander_xy))) {
          monster.giveup = 0;
          monster.wander_xy = null;
        }
        result.action = "move";
        result.xy = this.getWanderMove(monster);
      } else if ((monster.status === Brew.monster_status.ESCAPE) || monster.hasFlag(Brew.flags.is_scared)) {
        if (sense_player) {
          this.game.updatePathMapsFor(monster, true);
        }
        result.action = "move";
        result.xy = this.getMoveAwayFromPlayer(monster);
      } else if (monster.status === Brew.monster_status.HUNT && is_immobile) {
        if (sense_player && this.game.canAttack(monster, this.game.my_player)) {
          result.action = "attack";
          result.xy = this.game.my_player.coordinates;
          result.target = this.game.my_player;
        } else {
          result.action = "wait";
        }
      } else if (monster.status === Brew.monster_status.HUNT && (!is_immobile)) {
        keeps_distance = monster.hasFlag(Brew.flags.keeps_distance);
        if (sense_player) {
          this.game.updatePathMapsFor(monster, keeps_distance);
          decision = this.getKeepDistanceDirection(monster);
          if (keeps_distance && decision === "forward") {
            result.action = "move";
            result.xy = this.getMoveTowardsPlayer(monster);
          } else if (keeps_distance && decision === "back") {
            result.action = "move";
            result.xy = this.getMoveAwayFromPlayer(monster);
          } else {
            special_ability = this.canUseSpecialAbility(monster);
            if (special_ability) {
              result.action = "special";
              this.doSpecialAbility(monster, special_ability);
            } else if (this.game.canAttack(monster, this.game.my_player)) {
              result.action = "attack";
              result.xy = this.game.my_player.coordinates;
              result.target = this.game.my_player;
            } else if (keeps_distance) {
              result.action = "stand";
            } else {
              result.action = "move";
              result.xy = this.getMoveTowardsPlayer(monster);
            }
          }
        } else {
          result.action = "move";
          result.xy = this.game.findMove_AStar(monster, monster.coordinates, monster.last_player_xy);
        }
      }
      if (result.action === "move" && is_immobile) {
        result.action = "wait";
      } else if (result.action === "move") {
        if (result.xy == null) {
          result.action = "wait";
        } else {
          monster_at = this.game.my_level.getMonsterAt(result.xy);
          if (monster_at != null) {
            if (monster_at.group === "player") {
              result.action = "attack";
              result.target = this.game.my_player;
            } else if (monster.status === Brew.monster_status.ESCAPE && monster_at.status === Brew.monster_status.ESCAPE) {
              monster_at.pathmaps[Brew.paths.from_player] = monster.pathmaps[Brew.paths.from_player];
              result.action = "wait";
            } else {
              result.action = "wait";
              result.xy = null;
              result.target = null;
            }
          }
        }
      }
      return result;
    };

    Intel.prototype.getWanderMove = function(monster) {
      var next_xy;
      if (monster.wander_xy == null) {
        monster.wander_xy = this.game.my_level.getRandomWalkableLocation();
      } else if (monster.wander_xy.compare(monster.coordinates)) {
        monster.wander_xy = this.game.my_level.getRandomWalkableLocation();
      }
      next_xy = this.game.findMove_AStar(monster, monster.coordinates, monster.wander_xy);
      return next_xy;
    };

    Intel.prototype.getKeepDistanceDirection = function(monster) {
      var stand_value;
      stand_value = monster.pathmaps[Brew.paths.to_player][monster.coordinates.toKey()];
      if (stand_value < monster.attack_range) {
        return "back";
      } else if (stand_value > monster.attack_range) {
        return "forward";
      } else {
        return "stand";
      }
    };

    Intel.prototype.getMoveAwayFromPlayer = function(monster) {
      var m, next_xy, path_xy;
      next_xy = null;
      if (monster.pathmaps[Brew.paths.from_player] == null) {
        console.log("monster tried to run away without escape map");
        return next_xy = getWanderMove(monster);
      } else {
        path_xy = Brew.PathMap.getDownhillNeighbor(monster.pathmaps[Brew.paths.from_player], monster.coordinates).xy;
        if (path_xy == null) {
          return console.log("getMoveAwayFromPlayer null path");
        } else {
          m = this.game.my_level.getMonsterAt(path_xy);
          if ((m != null) && m.group !== "player" && !Brew.utils.compareThing(monster, m)) {
            return console.log("getMoveAwayFromPlayer monster collision");
          } else {
            return next_xy = path_xy;
          }
        }
      }
    };

    Intel.prototype.getMoveTowardsPlayer = function(monster) {
      var m, next_xy, path_xy;
      next_xy = null;
      if (this.game.pathmaps[Brew.paths.to_player] == null) {
        console.log("monster tried to move towards player without map");
      } else {
        path_xy = Brew.PathMap.getDownhillNeighbor(this.game.pathmaps[Brew.paths.to_player], monster.coordinates).xy;
        m = path_xy != null ? this.game.my_level.getMonsterAt(path_xy) : null;
        if ((path_xy == null) || ((m != null) && m.group !== "player")) {
          next_xy = this.game.findMove_AStar(monster, monster.coordinates, this.game.my_player.coordinates);
          console.log(("astar override for " + monster.id + ": ") + next_xy);
        } else {
          next_xy = path_xy;
        }
      }
      return next_xy;
    };

    Intel.prototype.canUseSpecialAbility = function(monster) {
      var can_use, get_zombies, m;
      can_use = null;
      if (monster.hasFlag(Brew.flags.summons_zombies)) {
        get_zombies = (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.game.my_level.getMonsters();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if ((_ref1 = m.group.toUpperCase()) === "ZOMBIE" || _ref1 === "ZOMBIE_LIMB") {
              _results.push(m);
            }
          }
          return _results;
        }).call(this);
        if (get_zombies.length === 0) {
          can_use = Brew.flags.summons_zombies;
        }
      }
      return can_use;
    };

    Intel.prototype.doSpecialAbility = function(monster, special_ability) {
      var summon_type, xy, z, zombies_at_a_time, _i, _len, _ref;
      if (special_ability === Brew.flags.summons_zombies) {
        this.msg(monster.name + " raises the dead!");
        if (monster.horde == null) {
          monster.horde = new Brew.Horde([monster]);
        }
        zombies_at_a_time = 0;
        _ref = Brew.utils.fisherYatesShuffle(monster.coordinates.getSurrounding());
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xy = _ref[_i];
          if ((this.game.my_level.getMonsterAt(xy) == null) && !this.game.my_level.getTerrainAt(xy).blocks_walking) {
            summon_type = ROT.RNG.getUniform() < 0.70 ? "ZOMBIE" : "ZOMBIE_LIMB";
            z = Brew.monsterFactory(summon_type, {
              status: Brew.monster_status.HUNT
            });
            z.color = [50 + Math.floor(ROT.RNG.getUniform() * 200), 50 + Math.floor(ROT.RNG.getUniform() * 200), 50 + Math.floor(ROT.RNG.getUniform() * 200)];
            monster.horde.add(z);
            this.game.my_level.setMonsterAt(xy, z);
            this.game.scheduler.add(z, true);
            this.game.ui.drawMapAt(xy);
            zombies_at_a_time += 1;
            if (zombies_at_a_time === 3) {
              break;
            }
          }
        }
        monster.horde.updateAll(monster.last_player_xy);
        return true;
      } else {
        console.log("unrecognized special ability: " + special_ability);
        return false;
      }
    };

    return Intel;

  })();

}).call(this);

//# sourceMappingURL=intel.map
